"""This module contains functions for choosing and reading a kinetic
mechanism from a mec file generated by DCPROGS.
"""

from array import array
import numpy as np

import dcpyps

def mec_get_list(mecfile):
    """
    Read list of mechanisms saved in mec file.

    Parameters
    ----------
    mecfile : filename

    Returns
    -------
    version : int
        Version of mec file.
    meclist : list
        Each element is another list containing:
        jstart : int
            Start byte for mechanism in mefile.
        mecnum : int
            Mechanism sequence number in mecfile.
        mectitle : string
        ratetitle : string
    max_mecnum : int
        Number of different mechanisms in mec file.
    """

    f = open(mecfile, 'rb')
    ints = array('i')

    # Read version of mec file. Latest version is 102.
    ints.fromfile(f,1)
    version = ints.pop()

    # Read number of rate sets (records) stored in the file
    ints.fromfile(f,1)
    nrecs = ints.pop()

    # Read byte value for next record
    ints.fromfile(f,1)
    nextrec = ints.pop()

    # Read byte value where last record starts
    ints.fromfile(f,1)
    ireclast = ints.pop()

    # Read start byte value for storage of the ith record
    jstart = np.zeros(nrecs, 'int32')    # jstart()- start byte # for storage of the ith record (2000 bytes)
    for i in range(nrecs):
        ints.fromfile(f, 1)
        jstart[i] = ints.pop()

    meclist = []
    max_mecnum = 0
    for i in range(nrecs):
        f.seek(jstart[i] - 1 + 4)
        ints.fromfile(f,1)
        mecnum = ints.pop()
        if mecnum > max_mecnum:
            max_mecnum = mecnum
        mectitle = f.read(74)
        ints.fromfile(f,5)
        ratetitle = f.read(74)
        
        set = []
        set.append(jstart[i])
        set.append(mecnum)
        set.append(mectitle)
        set.append(ratetitle)
        meclist.append(set)

    f.close()
    return version, meclist, max_mecnum

def mec_choose_from_list(meclist, max_mecnum):
    """
    Choose mechanism from a list of mechanisms in file.

    Parameters
    ----------
    meclist : list
        Each element is another list containing:
        jstart : int
            Start byte for mechanism in mefile.
        mecnum : int
            Mechanism sequence number in mecfile.
        mectitle : string
        ratetitle : string
    max_mecnum : int
        Number of different mechanisms in mec file.

    Returns
    -------
    mecnum : int
        Sequence number of a mechanism to read.
    ratenum : int
        Sequence number of rate set to read.
    """

    # List all mechs and choose one.
    print ' Model #              title'
    ndisp = 0
    for i in range(1, (max_mecnum + 1)):
            present = False
            id = 0
            for j in range(len(meclist)):
                if i == meclist[j][1]:
                    present = True
                    id = j
            if present:
                print i, meclist[id][2]
                ndisp += 1
                if ndisp % 20 == 0:
                    raw_input('\n   Hit ENTER for more... \n')
    try:
        mecnum = int(raw_input(
            "\nWhich mechanism would you like to read (1 to %d)? ... "
            %max_mecnum))
    except:
        print "\nError: model number not entered!"
        mecnum = max_mecnum

    # List and choose rate constants.
    print (
        "\nFor model %d the following rate constants have been stored:"
        %mecnum)

    ndisp = 0
    for i in range(len(meclist)):
       if meclist[i][1] == mecnum:
           print (i+1), meclist[i][3]
           ndisp += 1
           if ndisp % 20 == 0:
               raw_input("\n   Hit ENTER for more... \n")
    try:
        ratenum = (int(raw_input(
            "\nWhich rate set would you like to read?... ")) - 1)
    except:
        print "Error: rate set number not entered!"

    if (ratenum < 0) or (ratenum > len(meclist)):
        print "Error: not valid rate set number!"

    return mecnum, ratenum

def mec_load(mecfile, start):
    """
    Load chosen mec.

    Parameters
    ----------
    mecfile : filename
    start : int
        Start byte in mecfile for mechanism to read.

    Returns
    -------
    mec.Mechanism(RateList, StateList, ncyc) : instance of Mechanism class.
    """

    # Make dummy arrays to read floats, integers and short integers.
    doubles = array('d')
    floats = array ('f')
    ints = array('i')

    f=open(mecfile, 'rb')	# open the .mec file as read only
    f.seek(start - 1);
    ints.fromfile(f, 1)
    version1 = ints.pop()
    ints.fromfile(f, 1)
    mecnum = ints.pop()
    mectitle = f.read(74);

    # Read number of states.
    ints.fromfile(f,1)
    k = ints.pop()
    ints.fromfile(f,1)
    kA = ints.pop()
    ints.fromfile(f,1)
    kB = ints.pop()
    ints.fromfile(f,1)
    kC = ints.pop()
    ints.fromfile(f,1)
    kD = ints.pop()

    # In mec files version=103 all shut states are of type 'C'.
    # Check and leave just one in state 'C', others go as 'B'.
    if kB == 0:
        kB = kC - 1
        kC = 1

    ratetitle = f.read(74)

    # Read size of chess board to draw mechanism.
    ints.fromfile(f,1)
    ilast = ints.pop()
    ints.fromfile(f,1)
    jlast= ints.pop()

    # nrateq- number of non-zero rates in Q; = 2*ncon (always)
    ints.fromfile(f,1)
    nrateq = ints.pop()

    # Number of connections.
    ints.fromfile(f,1)
    ncon = ints.pop()

    # Number of concentration dependent rates
    ints.fromfile(f,1)
    ncdep = ints.pop()

    # Number of ligands
    ints.fromfile(f,1)
    nlig = ints.pop()

    # ? if char mechanism is presnt
    ints.fromfile(f,1)
    chardef = ints.pop()

    # ???
    ints.fromfile(f,1)
    boundef = ints.pop()

    # Number of cycles.
    ints.fromfile(f,1)
    ncyc = ints.pop()

    # Voltage.
    floats.fromfile(f,1)
    vref = floats.pop()

    # Number of voltage dependent rates.
    ints.fromfile(f,1)
    nvdep = ints.pop()

    # ???
    ints.fromfile(f,1)
    kmfast = ints.pop()

    # Independent subunit model.
    # False for all old models (npar=nrateq=2*ncon)
    # True when npar < nrateq=2*ncon. In this case must have nsetq>0
    ints.fromfile(f,1)
    indmod = ints.pop()

    # Number of basic rates constants.
    # Normally npar=nrateq and nsetq=0, but when indmod=T then npar<nrateq.
    ints.fromfile(f,1)
    npar = ints.pop()

    # ???
    ints.fromfile(f,1)
    nsetq = ints.pop()

    # ???
    ints.fromfile(f,1)
    kstat = ints.pop()

    # Output of mechanism in characters
    # TODO clean characters
    Jch = []
    for j in range(0, jlast):
        Ich = []
        for i in range(0, ilast):  # 500 is max
             charmod = f.read(2)
             Ich.append(charmod)
        Jch.append(Ich)
    for i in range(0,ilast):
        IIch = []
        for j in range(0, jlast):
            IIch.append(Jch[j][i])
        print ''.join(IIch)

    # Read rate constants.
    irate = []
    for i in range(nrateq):
        ints.fromfile(f,1)
        irate.append(ints.pop())
    jrate = []
    for i in range(nrateq):
        ints.fromfile(f,1)
        jrate.append(ints.pop())
    QT = np.zeros((k, k), 'float64')
    for i in range(nrateq):
        doubles.fromfile(f, 1)
        QT[irate[i]-1, jrate[i]-1] = doubles.pop()
    ratename = []
    for i in range(npar):
        ratename.append(f.read(10))
        #print ratename[i], "QT[",irate[i],",",jrate[i],"]=", QT[irate[i]-1,jrate[i]-1]

    # Read ligand name and ligand molecules bound in each state.
    for j in range(0, nlig):
        ligname = f.read(20)
        #print "Number of ligand %s molecules bound to states:" %ligname
    nbound = np.zeros((nlig,k), 'int32')
    for i in range(nlig):
        for j in range(k):
            ints.fromfile(f, 1)
            nbound[i,j] = ints.pop()
        #print "to state",j+1,":",nbound[i,j]

    # Read concentration dependent rates.
    # from state
    ix = []
    for i in range(0, ncdep):
        ints.fromfile(f,1)
        ix.append(ints.pop())
    # to state
    jx = []
    for j in range(0, ncdep):
        ints.fromfile(f,1)
        jx.append(ints.pop())
        #if verbose: print "jx[",j,"]=",jx[j]
    # ligand bound in that particular transition
    il = []
    for i in range(0, ncdep):
        ints.fromfile(f,1)
        il.append(ints.pop())
        #if verbose: print "il[", i, "]=", il[i]

    # Read open state conductance.
    dgamma = []
    for j in range(0, kA):
        doubles.fromfile(f,1)
        dgamma.append(doubles.pop())

    # Get number of states in each cycle and connections.
    nsc = np.zeros(50, 'int32')
    for i in range(0, ncyc):
        ints.fromfile(f,1)
        nsc[i] = ints.pop()
    #print "nsc[", i, "]=", nsc[i]
    im = np.zeros((50, 100), 'int32')
    for i in range(0, ncyc):
        for j in range(0, nsc[i]):
            ints.fromfile(f,1)
            im[i, j] = ints.pop()
            #print "im[",i,",",j,"]=",im[i,j]
    jm = np.zeros((50,100), 'int32')
    for i in range(0, ncyc):
        for j in range(0, nsc[i]):
            ints.fromfile(f,1)
            jm[i,j] = ints.pop()
            #print "jm[",i,",",j,"]=",jm[i,j]

    # Read voltage dependent rates.
    # from state
    iv = []
    for i in range(0, nvdep):
        ints.fromfile(f,1)
        iv.append(ints.pop())
        #print "iv[",i,"]=",iv[i]
    # to state
    jv = []
    for j in range(0, nvdep):
        ints.fromfile(f,1)
        jv.append(ints.pop())
        #print "jv[", j,"]=",jv[j]

    hpar = []
    for i in range(0, nvdep):
        floats.fromfile(f,1)
        hpar.append(floats.pop())
        #print "hpar[",i,"]=",hpar[i]

    pstar = []
    for j in range(0, 4):
        floats.fromfile(f,1)
        pstar.append(floats.pop())
        #print "pstar[",j,"]=",pstar[j]

    kmcon = []
    for i in range(0, 9):
        ints.fromfile(f,1)
        kmcon.append(ints.pop())
        #print "kmcon[",i,"]=",kmcon[i]

    ieq = []
    for i in range(0, nsetq):
        ints.fromfile(f,1)
        ieq.append(ints.pop())
        #print "ieq[",i,"]=",ieq[i]

    jeq = []
    for j in range(0, nsetq):
        ints.fromfile(f,1)
        jeq.append(ints.pop())
        #print "jeq[", j, "]=", jeq[j]

    ifq = []
    for i in range(0,nsetq):
        ints.fromfile(f,1)
        ifq.append(ints.pop())
        #print "ifq[",i,"]=",ifq[i]

    jfq = []
    for j in range(0, nsetq):
        ints.fromfile(f,1)
        jfq.append(ints.pop())
        #print "jfq[",j,"]=",jfq[j]

    efacq = []
    for i in range(0, nsetq):
        floats.fromfile(f,1)
        efacq.append(floats.pop())
        #print "efacq[",i,"]=",efacq[i]

    statenames = []
    for i in range(0, kstat):
        statename = f.read(10)
        statenames.append(statename)
        #print "State name:", statename
    print "\n"

    ints.fromfile(f,1)
    nsub = ints.pop()
    ints.fromfile(f,1)
    kstat0 = ints.pop()
    ints.fromfile(f,1)
    npar0 = ints.pop()
    ints.fromfile(f,1)
    kcon = ints.pop()
    ints.fromfile(f,1)
    npar1 = ints.pop()
    ints.fromfile(f,1)
    ncyc0 = ints.pop()

    f.close()

    StateList = []
    j = 0
    for i in range(kA):
        StateList.append(dcpyps.State('A', statenames[j], dgamma[j]))
        j += 1
    for i in range(kB):
        StateList.append(dcpyps.State('B', statenames[j], 0))
        j += 1
    for i in range(kC):
        StateList.append(dcpyps.State('C', statenames[j], 0))
        j += 1
    for i in range(kD):
        StateList.append(dcpyps.State('D', statenames[j], 0))
        j += 1

    RateList = []
    for i in range(nrateq):
        cdep = False
        bound = None
        for j in range(ncdep):
            if ix[j] == irate[i] and jx[j] == jrate[i]:
                cdep = True
                bound = 'c'
        rate = QT[irate[i] - 1, jrate[i] - 1]
        # REMIS: please make sure the state indexing is correct
        RateList.append(dcpyps.Rate(rate, StateList[irate[i]-1],
            StateList[jrate[i]-1], name=ratename[i], eff=bound))

    return dcpyps.Mechanism(RateList, ncyc=ncyc)
    
def scn_read_header (fname):
    """
    Read SCN file header. SCN files are generated by SCAN program (DCprogs) and
    contain idealised single channel record.
    """

    # make dummy arrays to read floats, doubles and integers (LONG in C)
    floats = array ('f')
    ints = array('i')
    doubles = array('d')

    f = open(fname, 'rb')
    header = {}

    ints.fromfile(f,1)
    header['iscanver'] = ints.pop()
    # new scan files- version 104, 103 (simulated) and -103
    version = header['iscanver']
    #print 'version', version

    ints.fromfile(f,1)
    ioffset = ints.pop()
    header['ioffset'] = ioffset

    ints.fromfile(f,1)
    nint = ints.pop()
    header['nint'] = nint

    header['title'] = f.read(70)
    header['date'] = f.read(11)

    if version == -103:
        header['tapeID'] = f.read(24)
        ints.fromfile(f,1)
        header['ipatch'] = ints.pop()
        floats.fromfile(f,1)
        header['Emem'] = floats.pop()
        ints.fromfile(f,1)
        header['unknown1'] = ints.pop()
        floats.fromfile(f,1)
        header['avamp'] = floats.pop()
        floats.fromfile(f,1)
        header['rms'] = floats.pop()
        floats.fromfile(f,1)
        header['ffilt'] = floats.pop()
        floats.fromfile(f,1)
        calfac2 = floats.pop()
        header['calfac2'] = calfac2
        floats.fromfile(f,1)
        header['treso'] = floats.pop()
        floats.fromfile(f,1)
        header['tresg'] = floats.pop()

        f.close()
        return ioffset, nint, calfac2, header

    header['defname'] = f.read(6)
    header['tapeID'] = f.read(24)
    ints.fromfile(f,1)
    header['ipatch'] = ints.pop()
    ints.fromfile(f,1)
    header['npatch'] = ints.pop()
    floats.fromfile(f,1)
    header['Emem'] = floats.pop()
    floats.fromfile(f,1)
    header['temper'] = floats.pop()
    header['adcfil'] = f.read(30)
    header['qfile1'] = f.read(35)

    # logical; true if data from CJUMP file
    ints.fromfile(f,1)
    header['cjump'] = ints.pop()

    ints.fromfile(f,1)
    header['nfits'] = ints.pop()

    ints.fromfile(f,1)
    header['ntmax'] = ints.pop()

    ints.fromfile(f,1)
    header['nfmax'] = ints.pop()

    # Number of data points read into memory at each disk read -bigger
    # the better (max depends on how much RAM you have).
    # nbuf=131072		!=1024*128
    ints.fromfile(f,1)
    header['nbuf'] = ints.pop()

    # Number of extra points read in, at each end of data section to
    # allow display of transitions on section boundaries; 2048 is OK usually.
    ints.fromfile(f,1)
    header['novlap'] = ints.pop()

    # Sample rate (Hz)
    floats.fromfile(f,1)
    header['srate'] = floats.pop()

    # finter = microsec between data points; finter=1.e6/srate
    floats.fromfile(f,1)
    header['finter'] = floats.pop()

    # TSECT=time (microsec) from first point of one section to first point of next
    # tsect=float(nbuf)*finter
    floats.fromfile(f,1)
    header['tsect'] = floats.pop()

    # The first data point in data file, idata(1) starts at byte (record #) ioff+1
    ints.fromfile(f,1)
    header['ioff'] = ints.pop()

    ints.fromfile(f,1)
    header['ndat'] = ints.pop()

    # calc nsec etc here, in case default nbuf altered
    # if(ndat.lt.nbuf) nbuf=ndat    !allocate smaller array
    # nsec= 1 + (ndat-1)/nbuf  !number of sections
    ints.fromfile(f,1)
    header['nsec'] = ints.pop()

    # nrlast=ndat - (nsec-1)*nbuf  !number of idata in last section
    ints.fromfile(f,1)
    header['nrlast'] = ints.pop()

    floats.fromfile(f,1)
    header['avtot'] = floats.pop()

    ints.fromfile(f,1)
    header['navamp'] = ints.pop()

    floats.fromfile(f,1)
    avamp = floats.pop()
    header['avamp'] = avamp

    floats.fromfile(f,1)
    rms = floats.pop()
    header['rms'] = rms

    # Data will be written to disk at (approx) every nth transition, so
    # analysis can be restarted by using the ''restart'' option when SCAN reentered.
    ints.fromfile(f,1)
    header['nwrit'] = ints.pop()

    # nwsav=0		!used for auto disc write
    ints.fromfile(f,1)
    header['nwsav'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['newpar'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['opendown'] = ints.pop()

    # logical; Invert trace (openings must be downwards)
    ints.fromfile(f,1)
    header['invert'] = ints.pop()

    # logical; usepots=.false.
    ints.fromfile(f,1)
    header['usepots'] = ints.pop()

    # in SCAN: Display only (no step-response function)
    ints.fromfile(f,1)
    header['disp'] = ints.pop()

    # if(iscrit.eq.1): Percentage of full amplitude for critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.2): Multiple of RMS noise to define critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.1): smult=0.14 !scrit=0.14*avamp
    # if(iscrit.eq.2): smult=5. scrit=5.0*rms
    floats.fromfile(f,1)
    header['smult'] = floats.pop()

    ints.fromfile(f,1)
    header['scrit'] = ints.pop()

    ints.fromfile(f,1)
    header['vary'] = ints.pop()

    # Number of consecutive points beyond Scrit for a transition to be
    # deemed to have occurred. Default: ntrig=2
    ints.fromfile(f,1)
    header['ntrig'] = ints.pop()

    # navtest=ntrig-1 ; if(navtest.le.0) navtest=1
    # navtest=number averaged before average curlev is used, rather than
    # input curlev in FINDTRANS (NB must be less than ntrig, or, for
    # example, if input baseline is not close to current baseline
    # (ie baseline has drifted since last time) then will get a 'trigger'
    # straight away!
    ints.fromfile(f,1)
    header['navtest'] = ints.pop()

    # Trace will be amplified by this factor before display (but better to
    # amplify correctly BEFORE sampling). DGAIN=1.0
    floats.fromfile(f,1)
    header['dgain'] = floats.pop()

    # IBOFF=0		!BASELINE OFFSET FOR DISPLAY (ADC)
    ints.fromfile(f,1)
    header['iboff'] = ints.pop()

    # Factor by which trace is expanded when ''expand'' is first hit.
    # expfac=2.
    floats.fromfile(f,1)
    header['expfac'] = floats.pop()

    # Position of baseline on screen is offset to this level after initial
    # ''get piece of baseline on screen'' is completed.
    # bdisp=0.75 if openings downwards; bdisp=0.25 if openings upwards
    floats.fromfile(f,1)
    header['bdisp'] = floats.pop()

    ints.fromfile(f,1)
    header['ibflag'] = ints.pop()

    # Auto-fit to avoid sublevels if possible. In case of doubt fit brief
    # open-shut-open rather than fitting a sublevel.
    ints.fromfile(f,1)
    header['iautosub'] = ints.pop()

    # When opening crosses the red trigger line display stops with the
    # opening transition at this point on the x-axis of display.
    # xtrig=0.2: trigger at 20% of X axis on screen
    floats.fromfile(f,1)
    header['xtrig'] = floats.pop()

    # ndev='C:'; disk partition for Windows
    header['ndev'] = f.read(2)
    header['cdate'] = f.read(11)
    header['adctime'] = f.read(8)

    ints.fromfile(f, 1)
    header['nsetup'] = ints.pop()

    header['filtfile'] = f.read(20)

    # Low pass filter (Hz, -3dB)
    # later needs to be converted to kHz
    floats.fromfile(f, 1)
    ffilt = floats.pop()
    header['ffilt'] = ffilt

    # npfilt=number of points to jump forward after a transition, to start
    # search for next transition
    # npfilt1= number of data points for filter to go from 1% to 99%
    # npfilt1=ifixr((tf99-tf1)/finter)
    # npfilt=ifixr(float(npfilt1)*facjump)
    ints.fromfile(f, 1)
    header['npfilt'] = ints.pop()

    # sfac1=(yd2-yd1)/65536.
    # sfac1=sfac1*dgain			!true scal fac for ADC to pixel units
    floats.fromfile(f, 1)
    header['sfac1'] = floats.pop()

    # nscale=1 + ifix(alog(4096./(yd2-yd1))/alog(2.))
    # sfac2=sfac1*float(2**nscale)	!Converts ADC units to intermed units
    floats.fromfile(f, 1)
    header['sfac2'] = floats.pop()

    # sfac3=1.0/float(2**nscale) 	!converts intermed to pixel units
    floats.fromfile(f, 1)
    header['sfac3'] = floats.pop()

    ints.fromfile(f, 1)
    header['nscale'] = ints.pop()

    # Calibration factor (pA per ADC unit)
    floats.fromfile(f, 1)
    header['calfac'] = floats.pop()

    # calfac1=calfac/sfac1		!converts pixel display units to pA
    floats.fromfile(f, 1)
    header['calfac1'] = floats.pop()

    # calfac2=calfac/sfac2		!converts intermed units to pA
    floats.fromfile(f, 1)
    calfac2 = floats.pop()
    header['calfac2'] = calfac2

    # iyoff=ifixr(yd1 + 0.5*(yd2-yd1))	!zero in centre until baseline done
    # (NB iyoff is in pixel units)
    ints.fromfile(f, 1)
    header['iyoff'] = ints.pop()

    ints.fromfile(f, 1)
    header['ioff1'] = ints.pop()

    # Show position of guessed transition points on screen as purple line
    # + blue line to mark end of transition.
    ints.fromfile(f, 1)
    header['disptran'] = ints.pop()

    # When first derivative used to identify two closely-spaced
    # transitions, display it below the trace.
    ints.fromfile(f, 1)
    header['dispderiv'] = ints.pop()

    # dispguess=.true.
    ints.fromfile(f, 1)
    header['dispguess'] = ints.pop()

    # Amplitude difference (as fraction of full amp) below which openings
    # are deemed to have ''same'' amplitude: for (a) elim of short gaps
    # (b) setting guesses. ampfac=0.05
    floats.fromfile(f, 1)
    header['ampfac'] = floats.pop()

    # Length of fitted event (microsec) below which refit, omitting short
    # events, is offered.  Events guessed to be shorter than this are
    # rejected before fitting. tmin=15
    floats.fromfile(f, 1)
    header['tmin'] = floats.pop()

    # Length (multiple of risetime) of event below which its amplitude is
    # fixed (also length guessed from peak amplitude).
    # tsfac=2.0		!tsfac*trise=tshort
    floats.fromfile(f, 1)
    header['tsfac'] = floats.pop()

    # Length (multiple of risetime) of event above which amplitude is
    # ''well-defined'' so usable to fix length of an adjacent brief opening.
    # tlfac=3.0		!tlfac*trise=tlong
    floats.fromfile(f, 1)
    header['tlfac'] = floats.pop()

    # sdone=.false.	!no baseline SD yet -NO -set BEFORE INSCAN
    ints.fromfile(f, 1)
    header['sdone'] = ints.pop()

    # real*8 in fortran;double precizion value of finter
    # Need double prec versions of finter if time of transition from 1st point
    # in CONSAM to be recorded accurately (see FITSUB).  At present, cannot
    # have smaller finter than 0.25 microsec (with 4 MHz clock) so want to get
    # rid of non sig figs when DBLE(finter) is calc
    doubles.fromfile(f, 1)
    header['dfinter'] = doubles.pop()

    doubles.fromfile(f, 1)
    header['tlast'] = doubles.pop()

    ints.fromfile(f, 1)
    header['shut'] = ints.pop()

    ints.fromfile(f, 1)
    header['shutprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['backward'] = ints.pop()

    ints.fromfile(f, 1)
    header['prevlevel'] = ints.pop()

    floats.fromfile(f, 1)
    header['t0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['y0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['vard'] = floats.pop()

    # Number of points before first, and after last, transition to be
    # fitted in auto mode. Number of shut points to be fitted at ends.
    # Default: nshutfit=50;
    ints.fromfile(f, 1)
    header['nshutfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['ixfprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['idiskq'] = ints.pop()

    ints.fromfile(f, 1)
    header['ifirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['base'] = ints.pop()

    ints.fromfile(f, 1)
    header['basevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['ibasevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrig'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrigvga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itriglev'] = ints.pop()

    ints.fromfile(f, 1)
    header['inc'] = ints.pop()

    ints.fromfile(f, 1)
    header['incabs'] = ints.pop()

    ints.fromfile(f, 1)
    header['indfast'] = ints.pop()

    ints.fromfile(f, 1)
    header['isdfst'] = ints.pop()

    ints.fromfile(f, 1)
    header['isec'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp1'] = ints.pop()

    #? idatyp=0 for usual CONSAM, idatyp=1 for pdpdata and
    #? idatyp=2 for Axon data
    ints.fromfile(f, 1)
    header['idatyp1'] = ints.pop()

    header['cdate1'] = f.read(11)

    # number of channels in patch
    ints.fromfile(f, 1)
    header['nchan'] = ints.pop()

    # Length (multiple of risetime) of interval between two transitions
    # (in same direction) below which an attempt is made to fit brief
    # events rather than sublevel.
    # tcfac=4.		!tcfac*trise=tclose
    # ''Close'' transitions (multiple of risetime)'	!tclose
    floats.fromfile(f, 1)
    header['tcfac'] = floats.pop()

    # Fraction of step-response (filter) length (1-99%) allowed after a
    # transition before search for next transition is started. facjump=0.6
    floats.fromfile(f, 1)
    header['facjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['shutsav'] = ints.pop()

    ints.fromfile(f, 1)
    header['goback'] = ints.pop()

    ints.fromfile(f, 1)
    header['imin'] = ints.pop()

    ints.fromfile(f, 1)
    header['imax'] = ints.pop()

    # Factor by which initial guess must be reduced before Simplex
    # converges; (e.g. 0.01=low precision; 0.0001=high precision)
    # errfac=0.005
    floats.fromfile(f, 1)
    header['errfac'] = floats.pop()

    # Multiple of SD of 1st deriv used to find inflections; small value
    # e.g. 2.0 makes it more likely that multiple transitions fitted,
    # rather than sublevel. Sensitivity for multiple trans (vs sublevel).
    # derivfac=3.
    floats.fromfile(f, 1)
    header['derivfac'] = floats.pop()

    # Controls how fast the simplex contracts around a putative minimum.
    # Usually 0.5; smaller value (down to 0.2) gives faster convergence
    # but fit may be worse.
    floats.fromfile(f, 1)
    header['confac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nsweep'] = ints.pop()

    # njdim=nsamp/njump
    ints.fromfile(f, 1)
    header['njdim'] = ints.pop()

    doubles.fromfile(f, 1)
    header['tzerod'] = doubles.pop()

    floats.fromfile(f, 1)
    header['intzero'] = floats.pop()

    # real*8 in fortran
    doubles.fromfile(f, 1)
    header['tsample'] = doubles.pop()

    floats.fromfile(f, 1)
    header['ktjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['njfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['njump'] = ints.pop()

    ints.fromfile(f, 1)
    header['nnull'] = ints.pop()

    floats.fromfile(f, 1)
    header['ktlast'] = floats.pop()

    #Default zoom factor (must be an integer power of 2 (i.e. 1,2,4,8...etc)
    ints.fromfile(f, 1)
    header['izoom'] = ints.pop()

    # Filter cut-off (Hz, -3 dB) when zoomed (default = same as input data,
    # i.e. no extra filtering when zoomed)
    floats.fromfile(f, 1)
    header['fcz'] = floats.pop()

    # fczoom=actual fc applied to achieve fcz (in kHz)
    # fczoom=1./sqrt((1.0/(fcz*fcz)) - (1.0/(ffilt*ffilt)))
    floats.fromfile(f, 1)
    header['fczoom'] = floats.pop()

    # ''Full amplitude'' to be used to identify transitions when zoomed
    # (approx size of small channels).
    # avampz=alternative 'full amplitude' to use for event detection
    # when zoomed/filtered (NB use zoomfac=1 or fczoom=filtf to get
    # filtering only or zoom only). avampz in intermed units
    # (same as avamp); ampz=same thing pA
    floats.fromfile(f, 1)
    header['ampz'] = floats.pop()

    floats.fromfile(f, 1)
    header['avampsav'] = floats.pop()

    # No. of iterations done by SIMPLEX before swapping to DFPMIN
    # (Davidon-Fletcher-Powell minimisation) when both used.
    # itsimp=1200
    ints.fromfile(f, 1)
    header['itsimp'] = ints.pop()

    # 1=SIMPLEX only (as before). 2=SIMPLEX for fixed number of iterations,
    # then swap to DFPMIN. 3=Davidon-Fletcher-Powell (DFPMIN) only.
    ints.fromfile(f, 1)
    header['minmeth'] = ints.pop()

    # Minimum # of points at the shut level within a fit required for this
    # shut level to be used to estimate the amplitude of nearby openings.
    # nbasemin=10
    ints.fromfile(f, 1)
    header['nbasemin'] = ints.pop()

    # Definition of threshold for detecting transitions: 1=fraction of
    # mean full amp; 2=multiple of rms noise. (Level is set as
    # parameter 3, page 1).
    # iscrit=1 to use scrit=smult*avamp (recent versions of scan)
    # iscrit=2 to use scrit=smult*rms (as in original version of scan)
    # latter could be better for records with wide range of amps
    ints.fromfile(f, 1)
    header['iscrit'] = ints.pop()

    # Use reduced critical amplitude for detecting transitions when all
    # amplitudes in the fit are smaller than the full amplitude.
    # Use variable critical level (see HELP)
    # default scritvar=.false.
    # if scritvar=true, smaller scrit is used for fittings that have only
    # small amplitudes. In this case value of scrit changed after region
    # to be fitted has been defined, with minimum smult=smultmin
    ints.fromfile(f, 1)
    header['scritvar'] = ints.pop()

    # Minimum crit level when using lower threshold for detecting
    # transitions when all amplitudes in the fit are smaller than the
    # full amplitude (as mult of RMS).
    # smultmin=2.5		!2.5*rms1 in intermed units
    # Minimum critical level (see HELP): multiple of RMS
    floats.fromfile(f, 1)
    header['smultmin'] = floats.pop()

    floats.fromfile(f, 1)
    header['stpfac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nlig'] = ints.pop()

    floats.fromfile(f, 1)
    header['conc1'] = floats.pop()

    f.close() #    close the file

    #return ioffset, nint, calfac2, ffilt, rms, avamp, header
    return ioffset, nint, calfac2, header

def scn_read_data(fname, ioffset, nint, calfac2):
    """
    Read idealised data- intervals, amplitudes, flags- rom SCN file.

    Data=
    real*4 tint(1...nint) 	 4nint bytes
    integer*2 iampl(1..nint)   2nint bytes
    integer*1 iprops(1..nint)  nint  bytes
    Total storage needed = 7 * nint bytes

    integer*1 iprops(i) holds properties of ith duration and amplitude
    (integer*1 has range -128 to +127 (bit 7 set gives -128; can use bits 0-6)
    0 = all OK;
    1 = amplitude dubious = bit 0;
    2 = amplitude fixed = bit 1;
    4 = amplitude of opening constrained (see fixamp) = bit 2;
    8 = duration unusable = bit 3; etc
    and keep sum of values of more than one property is true.
    """

    tint = array ('f') # 4 byte float
    iampl = array ('h') # 2 byte integer
    iprops = array('b') # 1 byte integer

    f=open(fname, 'rb')
    f.seek(ioffset-1)
    tint.fromfile(f, nint)
    iampl.fromfile(f, nint)
    iprops.fromfile(f, nint)
    f.close()

    if tint[-1] == 0:
        if iprops[-1] != 8:
            # Last interval in file is shut an set as unusable.
            iprops[-1] = 8        
    else:
        # Last interval in file is open. An unusable shut time is inserted
        # at the end. Total number of intervals increased by one.
        tint.append(-1.0)
        iampl.append(0)
        iprops.append(8)

    return tint, iampl, iprops

def abf_read_header (filename):
    """
    Read Axon abf file header. Works only for version < 2.0. Read only 
    information required for gap-free data reading.
    """
    
    floats = array ('f')
    ints = array('i')
    shorts = array ('h')
    
    # h- a dictionary containing info from the abf file header
    h = {}

    fid = open(filename, 'rb')

    # read 'fFileSignature' [i.e. abf version) from header
    h['IFileSignature'] = fid.read(4)
    floats.fromfile(fid, 1)
    h['fFileVersionNumber'] = round(floats.pop() * 10) * 0.1
#    print 'File signature: ', h['IFileSignature'], h['fFileVersionNumber']

    shorts.fromfile(fid, 1)
    h['nOperationMode'] = shorts.pop()
#    if h['nOperationMode'] == 1:
#        print("Operation mode 1: event-driven, variable length")
#    elif h['nOperationMode'] == 2:
#        print("Operation mode 2: oscilloscope, loss free")
#    elif h['nOperationMode'] == 3:
#        print("Operation mode 3: gap-free")
#    elif h['nOperationMode'] == 4:
#        print("Operation mode 4: oscilloscope, high-speed")
#    elif h['nOperationMode'] == 5:
#        print("Operation mode 5: episodic stimulation")
#    else:
#        print("Operation mode undefined!")

    ints.fromfile(fid, 1)
    h['IActualAcqLength'] = ints.pop()
#    print("Actual number of ADC samples = {0:d}".format(h['IActualAcqLength']))

    fid.seek(20)
    ints.fromfile(fid, 1)
    h['IFileStartDate'] = str(ints.pop())
    ints.fromfile(fid, 1)
    h['IFileStartTime'] = str(ints.pop())
#    print("Experiment date: " + h['IFileStartDate'])
#    print("Experiment time: " + h['IFileStartTime'])

    fid.seek(40)
    ints.fromfile(fid, 1)
    h['IDataSectionPtr'] = ints.pop()
    fid.seek(100)
    shorts.fromfile(fid, 1)
    h['nDataFormat'] = shorts.pop()
#    print("Block number of start of Data section = {0:d}".
#        format(h['IDataSectionPtr']))
#    offset = h['IDataSectionPtr'] * 512
#    print("     offset = {0:d}".format(offset))
#    print("Data representation (0- short int; 1- float): {0:d}".
#        format(h['nDataFormat']))

    fid.seek(120)
    shorts.fromfile(fid, 1)
    h['nADCNumChannels'] = shorts.pop()
#    print("Number of analog input channels sampled = {0:d}".
#        format(h['nADCNumChannels']))

    floats.fromfile(fid, 1)
    h['fADCSampleInterval'] = floats.pop()
#    print("Sampling interval = {0:.1f} microsec".
#        format(h['fADCSampleInterval'] * h['nADCNumChannels']))

    fid.seek(244)
    floats.fromfile(fid, 1)
    h['fADCRange'] = floats.pop()
#    print("ADC voltage range = {0:.1f} V".format(h['fADCRange']))
    fid.seek(252)
    ints.fromfile(fid, 1)
    h['IADCResolution'] = ints.pop()
#    print("Number of ADC counts = {0:d}".format(h['IADCResolution']))

    fid.seek(260)
    shorts.fromfile(fid, 1)
    h['nExperimentType'] = shorts.pop()
#    print("Experiment type (0- Voltage-clamp; 1- Current-clamp): {0:d}".
#        format(h['nExperimentType']))

    fid.seek(410)
    h['nADCSamplingSeq'] = []
    for i in range(16):
        shorts.fromfile(fid, 1)
        h['nADCSamplingSeq'].append(shorts.pop())
    h['sADCChannelName'] = []
    for i in range(16):
        h['sADCChannelName'].append(fid.read(10))
    h['sADCUnits'] = []
    for i in range(16):
        h['sADCUnits'].append(fid.read(8))
    
    # gains, offsets
    h['fADCProgramableGain'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCProgramableGain'].append(floats.pop())
    h['fADCDisplayAmplification'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCDisplayAmplification'].append(floats.pop())
    h['fADCDisplayOffset'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCDisplayOffset'].append(floats.pop())
    h['fInstrumentScaleFactor'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fInstrumentScaleFactor'].append(floats.pop())

#    print("Sampled ADC channels, names, units, gain:")
#    for i in range(h['nADCNumChannels']):
#        print("Channel # {0:d}\t".format(h['nADCSamplingSeq'][i]) +
#            h['sADCChannelName'][h['nADCSamplingSeq'][i]] + "\t" +
#            h['sADCUnits'][h['nADCSamplingSeq'][i]] + "\t" +
#            #"{0:.3f}".format(fADCProgramableGain[nADCSamplingSeq[i]]) + "\t" +
#            #"{0:.3f}".format(fADCDisplayAmplification[nADCSamplingSeq[i]]) + "\t" +
#            #"{0:.3f}".format(fADCDisplayOffset[nADCSamplingSeq[i]]) + "\t" +
#            "{0:.3f}".format(h['fInstrumentScaleFactor'][h['nADCSamplingSeq'][i]]) + " V/" +
#            h['sADCUnits'][h['nADCSamplingSeq'][i]])

    fid.seek(1178)
    h['fSignalLowpassFilter'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fSignalLowpassFilter'].append(floats.pop())
#    print("Lowpass filter = {0:.1f} Hz".
#        format(h['fSignalLowpassFilter'][h['nADCSamplingSeq'][0]]))

    fid.close()
    
    return h # header

def abf_read_data(filename, h):
    """
    Read data from Axon abf file . Works only for version < 2.0.
    """
    
    offset = h['IDataSectionPtr'] * 512
    samples = IActualAcqLength / nADCNumChannels
    if h['nDataFormat'] == 0:
        data_type = 'h'
    elif h['nDataFormat'] == 1:
        data_type = 'f'
    else:
        print("Can't read data. Data format not defined.")

    fid = open(filename, 'rb')    
    fid.seek(offset)
    
    # Read data block.
    temp = np.fromfile(fid, data_type)
    channels = np.reshape(temp, (samples, -1))
#    print(channels[:, 0])

    fid.close()

    return channels


def ssd_read_header (filename):
    """
    Read the header of a Consam file.
    """
    
    floats = array ('f')
    ints = array('i')
    shorts = array ('h')
    
    # h- a dictionary containing info from the abf file header
    h = {}
    f = open(filename, 'rb')
    
#    if verb: 
#        print("Full header from CONSAM file %s is as follows:" + filename)
#    else:
#        print("Highlights of CONSAM header from %s" + filename)
        
    shorts.fromfile(f,1)
    h['version'] = shorts.pop()
#    if verb: print "Version:", h['version'] # iver =1002 is new, =1001 is old

    h['title'] = f.read(70)
#    print "Title:", h['title']

    h['date'] = f.read(11)
#    if verb: print "Acquisition date:", h['date']

    h['time'] = f.read(8)
    #if verb: print "Acquisition time:", time
 
    shorts.fromfile(f,1)
    h['idt'] = shorts.pop()
#    if verb: print "idt:", idt
 
    ints.fromfile(f,1)
    h['ioff'] = ints.pop()
#    if verb: print "ioff:", ioff

    ints.fromfile(f,1)
    h['ilen'] = ints.pop()
#    if verb:
#        print "ilen:", ilen
#        print 'Attention! ilen gives length in bites, so- number of points is half of ilen'

    shorts.fromfile(f,1)
    h['inc'] = shorts.pop()
#    if verb: print "inc:", inc

    shorts.fromfile(f,1)
    h['id1'] = shorts.pop()
#    if verb: print "id1:", id1

    shorts.fromfile(f,1)
    h['id2'] = shorts.pop()
#    if verb: print "id2:", id2

    h['cs'] = f.read(3)
#    if verb: print "cs:", cs

    floats.fromfile(f,1)
    h['calfac'] = floats.pop()
#    print "calfac:", calfac

    floats.fromfile(f,1)
    h['srate'] = floats.pop()
#    print "Sample frequency: %i Hz" %int (srate)

    floats.fromfile(f,1)
    h['filt'] =floats.pop()
#    print "Filter frequency: %i Hz" %int (filt)

    floats.fromfile(f,1)
    h['filt1'] = floats.pop()
#    if verb: print "filt1:", filt1

    floats.fromfile(f,1)
    h['calfac1'] = floats.pop()
#    if verb: print "calfac1:", calfac1

    h['expdate'] = f.read(11)
#    if verb: print "Experiment date:", expdate

    h['defname'] = f.read(6)
#    if verb: print "defname:", defname

    h['tapeID'] = f.read(24)
#    if verb: print "Tape ID:", tapeID

    floats.fromfile(f,1)
    h['ipatch'] = floats.pop()
#    if verb: print"ipatch:", ipatch

    floats.fromfile(f,1)
    h['npatch'] = floats.pop()
#    if verb: print"npatch:", npatch

    floats.fromfile(f,1)
    h['Emem'] = floats.pop()
#    if verb: print "Transmembrane potential: %i mV" %int (Emem)

    floats.fromfile(f,1)
    h['temp'] = floats.pop()
#    if verb: print "Recording temperature: %i C" %int (temp)

    f.close()
    return h
