from array import array
import numpy as np

def read_header (fname, verbose=False):
    """
    Read SCN file header. SCN files are generated by SCAN program (DCprogs) and
    contain idealised single channel record.
    """

    # make dummy arrays to read floats, doubles and integers (LONG in C)
    floats = array ('f')
    ints = array('i')
    doubles = array('d')

    f = open(fname, 'rb')
    header = {}

    ints.fromfile(f,1)
    header['iscanver'] = ints.pop()
    # new scan files- version 104, 103 (simulated) and -103
    version = header['iscanver']
    if verbose: print ('version', version)

    ints.fromfile(f,1)
    ioffset = ints.pop()
    header['ioffset'] = ioffset

    ints.fromfile(f,1)
    nint = ints.pop()
    header['nint'] = nint

    header['title'] = f.read(70)
    header['date'] = f.read(11)

    if version == -103 or version == 103:
        header['tapeID'] = f.read(24)
        ints.fromfile(f,1)
        header['ipatch'] = ints.pop()
        floats.fromfile(f,1)
        header['Emem'] = floats.pop()
        ints.fromfile(f,1)
        header['unknown1'] = ints.pop()
        floats.fromfile(f,1)
        header['avamp'] = floats.pop()
        floats.fromfile(f,1)
        header['rms'] = floats.pop()
        floats.fromfile(f,1)
        header['ffilt'] = floats.pop()
        floats.fromfile(f,1)
        calfac2 = floats.pop()
        header['calfac2'] = calfac2
        floats.fromfile(f,1)
        header['treso'] = floats.pop()
        floats.fromfile(f,1)
        header['tresg'] = floats.pop()
        if version == 103:
            header['type'] = 'simulated'

        f.close()
        return header

    header['type'] = 'experiment'
    header['defname'] = f.read(6)
    header['tapeID'] = f.read(24)
    ints.fromfile(f,1)
    header['ipatch'] = ints.pop()
    ints.fromfile(f,1)
    header['npatch'] = ints.pop()
    floats.fromfile(f,1)
    header['Emem'] = floats.pop()
    floats.fromfile(f,1)
    header['temper'] = floats.pop()
    header['adcfil'] = f.read(30)
    header['qfile1'] = f.read(35)

    # logical; true if data from CJUMP file
    ints.fromfile(f,1)
    header['cjump'] = ints.pop()

    ints.fromfile(f,1)
    header['nfits'] = ints.pop()

    ints.fromfile(f,1)
    header['ntmax'] = ints.pop()

    ints.fromfile(f,1)
    header['nfmax'] = ints.pop()

    # Number of data points read into memory at each disk read -bigger
    # the better (max depends on how much RAM you have).
    # nbuf=131072		!=1024*128
    ints.fromfile(f,1)
    header['nbuf'] = ints.pop()

    # Number of extra points read in, at each end of data section to
    # allow display of transitions on section boundaries; 2048 is OK usually.
    ints.fromfile(f,1)
    header['novlap'] = ints.pop()

    # Sample rate (Hz)
    floats.fromfile(f,1)
    header['srate'] = floats.pop()

    # finter = microsec between data points; finter=1.e6/srate
    floats.fromfile(f,1)
    header['finter'] = floats.pop()

    # TSECT=time (microsec) from first point of one section to first point of next
    # tsect=float(nbuf)*finter
    floats.fromfile(f,1)
    header['tsect'] = floats.pop()

    # The first data point in data file, idata(1) starts at byte (record #) ioff+1
    ints.fromfile(f,1)
    header['ioff'] = ints.pop()

    ints.fromfile(f,1)
    header['ndat'] = ints.pop()

    # calc nsec etc here, in case default nbuf altered
    # if(ndat.lt.nbuf) nbuf=ndat    !allocate smaller array
    # nsec= 1 + (ndat-1)/nbuf  !number of sections
    ints.fromfile(f,1)
    header['nsec'] = ints.pop()

    # nrlast=ndat - (nsec-1)*nbuf  !number of idata in last section
    ints.fromfile(f,1)
    header['nrlast'] = ints.pop()

    floats.fromfile(f,1)
    header['avtot'] = floats.pop()

    ints.fromfile(f,1)
    header['navamp'] = ints.pop()

    floats.fromfile(f,1)
    avamp = floats.pop()
    header['avamp'] = avamp

    floats.fromfile(f,1)
    rms = floats.pop()
    header['rms'] = rms

    # Data will be written to disk at (approx) every nth transition, so
    # analysis can be restarted by using the ''restart'' option when SCAN reentered.
    ints.fromfile(f,1)
    header['nwrit'] = ints.pop()

    # nwsav=0		!used for auto disc write
    ints.fromfile(f,1)
    header['nwsav'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['newpar'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['opendown'] = ints.pop()

    # logical; Invert trace (openings must be downwards)
    ints.fromfile(f,1)
    header['invert'] = ints.pop()

    # logical; usepots=.false.
    ints.fromfile(f,1)
    header['usepots'] = ints.pop()

    # in SCAN: Display only (no step-response function)
    ints.fromfile(f,1)
    header['disp'] = ints.pop()

    # if(iscrit.eq.1): Percentage of full amplitude for critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.2): Multiple of RMS noise to define critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.1): smult=0.14 !scrit=0.14*avamp
    # if(iscrit.eq.2): smult=5. scrit=5.0*rms
    floats.fromfile(f,1)
    header['smult'] = floats.pop()

    ints.fromfile(f,1)
    header['scrit'] = ints.pop()

    ints.fromfile(f,1)
    header['vary'] = ints.pop()

    # Number of consecutive points beyond Scrit for a transition to be
    # deemed to have occurred. Default: ntrig=2
    ints.fromfile(f,1)
    header['ntrig'] = ints.pop()

    # navtest=ntrig-1 ; if(navtest.le.0) navtest=1
    # navtest=number averaged before average curlev is used, rather than
    # input curlev in FINDTRANS (NB must be less than ntrig, or, for
    # example, if input baseline is not close to current baseline
    # (ie baseline has drifted since last time) then will get a 'trigger'
    # straight away!
    ints.fromfile(f,1)
    header['navtest'] = ints.pop()

    # Trace will be amplified by this factor before display (but better to
    # amplify correctly BEFORE sampling). DGAIN=1.0
    floats.fromfile(f,1)
    header['dgain'] = floats.pop()

    # IBOFF=0		!BASELINE OFFSET FOR DISPLAY (ADC)
    ints.fromfile(f,1)
    header['iboff'] = ints.pop()

    # Factor by which trace is expanded when ''expand'' is first hit.
    # expfac=2.
    floats.fromfile(f,1)
    header['expfac'] = floats.pop()

    # Position of baseline on screen is offset to this level after initial
    # ''get piece of baseline on screen'' is completed.
    # bdisp=0.75 if openings downwards; bdisp=0.25 if openings upwards
    floats.fromfile(f,1)
    header['bdisp'] = floats.pop()

    ints.fromfile(f,1)
    header['ibflag'] = ints.pop()

    # Auto-fit to avoid sublevels if possible. In case of doubt fit brief
    # open-shut-open rather than fitting a sublevel.
    ints.fromfile(f,1)
    header['iautosub'] = ints.pop()

    # When opening crosses the red trigger line display stops with the
    # opening transition at this point on the x-axis of display.
    # xtrig=0.2: trigger at 20% of X axis on screen
    floats.fromfile(f,1)
    header['xtrig'] = floats.pop()

    # ndev='C:'; disk partition for Windows
    header['ndev'] = f.read(2)
    header['cdate'] = f.read(11)
    header['adctime'] = f.read(8)

    ints.fromfile(f, 1)
    header['nsetup'] = ints.pop()

    header['filtfile'] = f.read(20)

    # Low pass filter (Hz, -3dB)
    # later needs to be converted to kHz
    floats.fromfile(f, 1)
    ffilt = floats.pop()
    header['ffilt'] = ffilt

    # npfilt=number of points to jump forward after a transition, to start
    # search for next transition
    # npfilt1= number of data points for filter to go from 1% to 99%
    # npfilt1=ifixr((tf99-tf1)/finter)
    # npfilt=ifixr(float(npfilt1)*facjump)
    ints.fromfile(f, 1)
    header['npfilt'] = ints.pop()

    # sfac1=(yd2-yd1)/65536.
    # sfac1=sfac1*dgain			!true scal fac for ADC to pixel units
    floats.fromfile(f, 1)
    header['sfac1'] = floats.pop()

    # nscale=1 + ifix(alog(4096./(yd2-yd1))/alog(2.))
    # sfac2=sfac1*float(2**nscale)	!Converts ADC units to intermed units
    floats.fromfile(f, 1)
    header['sfac2'] = floats.pop()

    # sfac3=1.0/float(2**nscale) 	!converts intermed to pixel units
    floats.fromfile(f, 1)
    header['sfac3'] = floats.pop()

    ints.fromfile(f, 1)
    header['nscale'] = ints.pop()

    # Calibration factor (pA per ADC unit)
    floats.fromfile(f, 1)
    header['calfac'] = floats.pop()

    # calfac1=calfac/sfac1		!converts pixel display units to pA
    floats.fromfile(f, 1)
    header['calfac1'] = floats.pop()

    # calfac2=calfac/sfac2		!converts intermed units to pA
    floats.fromfile(f, 1)
    calfac2 = floats.pop()
    header['calfac2'] = calfac2

    # iyoff=ifixr(yd1 + 0.5*(yd2-yd1))	!zero in centre until baseline done
    # (NB iyoff is in pixel units)
    ints.fromfile(f, 1)
    header['iyoff'] = ints.pop()

    ints.fromfile(f, 1)
    header['ioff1'] = ints.pop()

    # Show position of guessed transition points on screen as purple line
    # + blue line to mark end of transition.
    ints.fromfile(f, 1)
    header['disptran'] = ints.pop()

    # When first derivative used to identify two closely-spaced
    # transitions, display it below the trace.
    ints.fromfile(f, 1)
    header['dispderiv'] = ints.pop()

    # dispguess=.true.
    ints.fromfile(f, 1)
    header['dispguess'] = ints.pop()

    # Amplitude difference (as fraction of full amp) below which openings
    # are deemed to have ''same'' amplitude: for (a) elim of short gaps
    # (b) setting guesses. ampfac=0.05
    floats.fromfile(f, 1)
    header['ampfac'] = floats.pop()

    # Length of fitted event (microsec) below which refit, omitting short
    # events, is offered.  Events guessed to be shorter than this are
    # rejected before fitting. tmin=15
    floats.fromfile(f, 1)
    header['tmin'] = floats.pop()

    # Length (multiple of risetime) of event below which its amplitude is
    # fixed (also length guessed from peak amplitude).
    # tsfac=2.0		!tsfac*trise=tshort
    floats.fromfile(f, 1)
    header['tsfac'] = floats.pop()

    # Length (multiple of risetime) of event above which amplitude is
    # ''well-defined'' so usable to fix length of an adjacent brief opening.
    # tlfac=3.0		!tlfac*trise=tlong
    floats.fromfile(f, 1)
    header['tlfac'] = floats.pop()

    # sdone=.false.	!no baseline SD yet -NO -set BEFORE INSCAN
    ints.fromfile(f, 1)
    header['sdone'] = ints.pop()

    # real*8 in fortran;double precizion value of finter
    # Need double prec versions of finter if time of transition from 1st point
    # in CONSAM to be recorded accurately (see FITSUB).  At present, cannot
    # have smaller finter than 0.25 microsec (with 4 MHz clock) so want to get
    # rid of non sig figs when DBLE(finter) is calc
    doubles.fromfile(f, 1)
    header['dfinter'] = doubles.pop()

    doubles.fromfile(f, 1)
    header['tlast'] = doubles.pop()

    ints.fromfile(f, 1)
    header['shut'] = ints.pop()

    ints.fromfile(f, 1)
    header['shutprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['backward'] = ints.pop()

    ints.fromfile(f, 1)
    header['prevlevel'] = ints.pop()

    floats.fromfile(f, 1)
    header['t0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['y0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['vard'] = floats.pop()

    # Number of points before first, and after last, transition to be
    # fitted in auto mode. Number of shut points to be fitted at ends.
    # Default: nshutfit=50;
    ints.fromfile(f, 1)
    header['nshutfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['ixfprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['idiskq'] = ints.pop()

    ints.fromfile(f, 1)
    header['ifirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['base'] = ints.pop()

    ints.fromfile(f, 1)
    header['basevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['ibasevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrig'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrigvga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itriglev'] = ints.pop()

    ints.fromfile(f, 1)
    header['inc'] = ints.pop()

    ints.fromfile(f, 1)
    header['incabs'] = ints.pop()

    ints.fromfile(f, 1)
    header['indfast'] = ints.pop()

    ints.fromfile(f, 1)
    header['isdfst'] = ints.pop()

    ints.fromfile(f, 1)
    header['isec'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp1'] = ints.pop()

    #? idatyp=0 for usual CONSAM, idatyp=1 for pdpdata and
    #? idatyp=2 for Axon data
    ints.fromfile(f, 1)
    header['idatyp1'] = ints.pop()

    header['cdate1'] = f.read(11)

    # number of channels in patch
    ints.fromfile(f, 1)
    header['nchan'] = ints.pop()

    # Length (multiple of risetime) of interval between two transitions
    # (in same direction) below which an attempt is made to fit brief
    # events rather than sublevel.
    # tcfac=4.		!tcfac*trise=tclose
    # ''Close'' transitions (multiple of risetime)'	!tclose
    floats.fromfile(f, 1)
    header['tcfac'] = floats.pop()

    # Fraction of step-response (filter) length (1-99%) allowed after a
    # transition before search for next transition is started. facjump=0.6
    floats.fromfile(f, 1)
    header['facjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['shutsav'] = ints.pop()

    ints.fromfile(f, 1)
    header['goback'] = ints.pop()

    ints.fromfile(f, 1)
    header['imin'] = ints.pop()

    ints.fromfile(f, 1)
    header['imax'] = ints.pop()

    # Factor by which initial guess must be reduced before Simplex
    # converges; (e.g. 0.01=low precision; 0.0001=high precision)
    # errfac=0.005
    floats.fromfile(f, 1)
    header['errfac'] = floats.pop()

    # Multiple of SD of 1st deriv used to find inflections; small value
    # e.g. 2.0 makes it more likely that multiple transitions fitted,
    # rather than sublevel. Sensitivity for multiple trans (vs sublevel).
    # derivfac=3.
    floats.fromfile(f, 1)
    header['derivfac'] = floats.pop()

    # Controls how fast the simplex contracts around a putative minimum.
    # Usually 0.5; smaller value (down to 0.2) gives faster convergence
    # but fit may be worse.
    floats.fromfile(f, 1)
    header['confac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nsweep'] = ints.pop()

    # njdim=nsamp/njump
    ints.fromfile(f, 1)
    header['njdim'] = ints.pop()

    doubles.fromfile(f, 1)
    header['tzerod'] = doubles.pop()

    floats.fromfile(f, 1)
    header['intzero'] = floats.pop()

    # real*8 in fortran
    doubles.fromfile(f, 1)
    header['tsample'] = doubles.pop()

    floats.fromfile(f, 1)
    header['ktjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['njfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['njump'] = ints.pop()

    ints.fromfile(f, 1)
    header['nnull'] = ints.pop()

    floats.fromfile(f, 1)
    header['ktlast'] = floats.pop()

    #Default zoom factor (must be an integer power of 2 (i.e. 1,2,4,8...etc)
    ints.fromfile(f, 1)
    header['izoom'] = ints.pop()

    # Filter cut-off (Hz, -3 dB) when zoomed (default = same as input data,
    # i.e. no extra filtering when zoomed)
    floats.fromfile(f, 1)
    header['fcz'] = floats.pop()

    # fczoom=actual fc applied to achieve fcz (in kHz)
    # fczoom=1./sqrt((1.0/(fcz*fcz)) - (1.0/(ffilt*ffilt)))
    floats.fromfile(f, 1)
    header['fczoom'] = floats.pop()

    # ''Full amplitude'' to be used to identify transitions when zoomed
    # (approx size of small channels).
    # avampz=alternative 'full amplitude' to use for event detection
    # when zoomed/filtered (NB use zoomfac=1 or fczoom=filtf to get
    # filtering only or zoom only). avampz in intermed units
    # (same as avamp); ampz=same thing pA
    floats.fromfile(f, 1)
    header['ampz'] = floats.pop()

    floats.fromfile(f, 1)
    header['avampsav'] = floats.pop()

    # No. of iterations done by SIMPLEX before swapping to DFPMIN
    # (Davidon-Fletcher-Powell minimisation) when both used.
    # itsimp=1200
    ints.fromfile(f, 1)
    header['itsimp'] = ints.pop()

    # 1=SIMPLEX only (as before). 2=SIMPLEX for fixed number of iterations,
    # then swap to DFPMIN. 3=Davidon-Fletcher-Powell (DFPMIN) only.
    ints.fromfile(f, 1)
    header['minmeth'] = ints.pop()

    # Minimum # of points at the shut level within a fit required for this
    # shut level to be used to estimate the amplitude of nearby openings.
    # nbasemin=10
    ints.fromfile(f, 1)
    header['nbasemin'] = ints.pop()

    # Definition of threshold for detecting transitions: 1=fraction of
    # mean full amp; 2=multiple of rms noise. (Level is set as
    # parameter 3, page 1).
    # iscrit=1 to use scrit=smult*avamp (recent versions of scan)
    # iscrit=2 to use scrit=smult*rms (as in original version of scan)
    # latter could be better for records with wide range of amps
    ints.fromfile(f, 1)
    header['iscrit'] = ints.pop()

    # Use reduced critical amplitude for detecting transitions when all
    # amplitudes in the fit are smaller than the full amplitude.
    # Use variable critical level (see HELP)
    # default scritvar=.false.
    # if scritvar=true, smaller scrit is used for fittings that have only
    # small amplitudes. In this case value of scrit changed after region
    # to be fitted has been defined, with minimum smult=smultmin
    ints.fromfile(f, 1)
    header['scritvar'] = ints.pop()

    # Minimum crit level when using lower threshold for detecting
    # transitions when all amplitudes in the fit are smaller than the
    # full amplitude (as mult of RMS).
    # smultmin=2.5		!2.5*rms1 in intermed units
    # Minimum critical level (see HELP): multiple of RMS
    floats.fromfile(f, 1)
    header['smultmin'] = floats.pop()

    floats.fromfile(f, 1)
    header['stpfac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nlig'] = ints.pop()

    floats.fromfile(f, 1)
    header['conc1'] = floats.pop()

    f.close() #    close the file

    #return ioffset, nint, calfac2, ffilt, rms, avamp, header
    return header

def read_data(fname, header):
    """
    Read idealised data- intervals, amplitudes, flags- rom SCN file.
    Data=
    real*4 tint(1...nint) 	 4nint bytes
    integer*2 iampl(1..nint)   2nint bytes
    integer*1 iprops(1..nint)  nint  bytes
    Total storage needed = 7 * nint bytes
    integer*1 iprops(i) holds properties of ith duration and amplitude
    (integer*1 has range -128 to +127 (bit 7 set gives -128; can use bits 0-6)
    0 = all OK;
    1 = amplitude dubious = bit 0;
    2 = amplitude fixed = bit 1;
    4 = amplitude of opening constrained (see fixamp) = bit 2;
    8 = duration unusable = bit 3; etc
    and keep sum of values of more than one property is true.
    """

    tint = array ('f') # 4 byte float
    iampl = array ('h') # 2 byte integer
    iprops = array('b') # 1 byte integer

    f=open(fname, 'rb')
    f.seek(header['ioffset']-1)
    tint.fromfile(f, header['nint'])
    iampl.fromfile(f, header['nint'])
    iprops.fromfile(f, header['nint'])
    f.close()
     
    if header['iscanver'] > 0:
        gapnotfound = True
        while gapnotfound:
            if iampl[-1] == 0:
                gapnotfound = False
                iprops[-1] = 8
            else:
                tint.pop()
                iampl.pop()
                iprops.pop()
        
    return np.array(tint)*0.001, np.array(iampl), np.array(iprops)

def write(intervals, amplitudes, flags, calfac=1.0, ffilt=-1.0, rms=0.0,
        treso=0.0, tresg=0.0, Emem=0.0,
        filename='new_saved.SCN', type='simulated'):
    """
    Write binary SCAN (DCprogs: http://www.ucl.ac.uk/Pharmacology/dcpr95.html)
    format file.
    Parameters
    ----------
    """

    # Preapare header.
    iscanver, ioffset = -103, 154
    nint, avamp = len(intervals), np.average(amplitudes)
    title = '{0: <70}'.format(type) # char*70
    t = time.asctime()
    expdate = t[8:10] + '-' + t[4:7] + '-' + t[20:24] # '00-ooo-0000' char*11
    tapeID = '{0: <24}'.format(type) # char*24
    ipatch = 0 # integer32

    # Write header.
    fout = open(filename, 'wb')
    fout.write(struct.pack('iii', iscanver, ioffset, nint))
    fout.write(bytes(title + expdate + tapeID, 'UTF-8'))
    fout.write(struct.pack('ififff', ipatch, Emem, 0, avamp, rms, ffilt))
    fout.write(struct.pack('fff', calfac, treso, tresg))

    # Write data block.
    fout.write(struct.pack('f'*nint, *intervals))
    fout.write(struct.pack('h'*nint, *amplitudes))
    fout.write(struct.pack('b'*nint, *flags))
    fout.close()
    
def convert_clampfit_to_scn(fname):
    """
    Convert
    """
    record = np.genfromtxt(fname, skip_header=1, delimiter=',')
    for i in range(len(record)):
        if np.isnan(record[i, 0]):
            record[i, 2] = 0
            record[i, 8] = record[i+1, 4] - record[i-1, 5]
    intervals = record[:, 8]
    amplitudes = record[:, 2].astype(int)
    flags = np.zeros((len(intervals)), dtype='b')
    to_filename = fname[:-3] + 'scn'
    scn_write(intervals, amplitudes, flags,
        filename=to_filename, type='Converted Clampfit ideal')
    return to_filename

def load_Clampfit_Excel_sheet(fname, sheet):
    """
    Convert Clampfit idealisation result saved as comma delimited .csv file.
    """
    
    record = pd.read_excel(fname, sheet, header=None)
    amplitudes = np.abs(record.iloc[1: , 6].values * record.iloc[1:, 2].values * 1000.0).astype(int)
    intervals = record.iloc[1: , 8].values
    flags = np.zeros((len(intervals)), dtype='b')
    return amplitudes, intervals, flags

