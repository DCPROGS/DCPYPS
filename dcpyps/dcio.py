"""This module contains functions for reading MEC, SCN, SSD, ABF files;
choosing and reading a kinetic mechanism from a mec file generated by DCPROGS.
"""

import struct
import time
import math
from array import array
import numpy as np
from pylab import figure, semilogx, savefig

import dcpyps
from dcpyps import mechanism
from dcpyps import scplotlib as scpl

def mec_get_list(mecfile):
    """
    Read list of mechanisms saved in mec file.

    Parameters
    ----------
    mecfile : filename

    Returns
    -------
    version : int
        Version of mec file.
    meclist : list; each element is another list containing
        jstart : int; start byte for mechanism in mefile.
        mecnum : int; mechanism sequence number in mecfile.
        mectitle : string
        ratetitle : string
    max_mecnum : int
        Number of different mechanisms in mec file.
    """

    f = open(mecfile, 'rb')
    ints = array('i')

    # Read version of mec file. Latest version is 102.
    ints.fromfile(f,1)
    version = ints.pop()

    # Read number of rate sets (records) stored in the file
    ints.fromfile(f,1)
    nrecs = ints.pop()

    # Read byte value for next record
    ints.fromfile(f,1)
    nextrec = ints.pop()

    # Read byte value where last record starts
    ints.fromfile(f,1)
    ireclast = ints.pop()

    # Read start byte value for storage of the ith record
    jstart = np.zeros(nrecs, 'int32')    # jstart()- start byte # for storage of the ith record (2000 bytes)
    for i in range(nrecs):
        ints.fromfile(f, 1)
        jstart[i] = ints.pop()

    meclist = []
    max_mecnum = 0
    for i in range(nrecs):
        f.seek(jstart[i] - 1 + 4)
        ints.fromfile(f,1)
        mecnum = ints.pop()
        if mecnum > max_mecnum:
            max_mecnum = mecnum
        mectitle = f.read(74)
        ints.fromfile(f,5)
        ratetitle = f.read(74)
        
        set = []
        set.append(jstart[i])
        set.append(mecnum)
        set.append(mectitle)
        set.append(ratetitle)
        meclist.append(set)

    f.close()
    return version, meclist, max_mecnum

def mec_choose_from_list(meclist, max_mecnum):
    """
    Choose mechanism from a list of mechanisms in file.

    Parameters
    ----------
    meclist : list; each element is another list containing:
        jstart : int; start byte for mechanism in mefile.
        mecnum : int; mechanism sequence number in mecfile.
        mectitle : string
        ratetitle : string
    max_mecnum : int
        Number of different mechanisms in mec file.

    Returns
    -------
    mecnum : int
        Sequence number of a mechanism to read.
    ratenum : int
        Sequence number of rate set to read.
    """

    # List all mechs and choose one.
    print ' Model #              title'
    ndisp = 0
    for i in range(1, (max_mecnum + 1)):
            present = False
            id = 0
            for j in range(len(meclist)):
                if i == meclist[j][1]:
                    present = True
                    id = j
            if present:
                print i, meclist[id][2]
                ndisp += 1
                if ndisp % 20 == 0:
                    raw_input('\n   Hit ENTER for more... \n')
    try:
        mecnum = int(raw_input(
            "\nWhich mechanism would you like to read (1 to %d)? ... "
            %max_mecnum))
    except:
        print "\nError: model number not entered!"
        mecnum = max_mecnum

    # List and choose rate constants.
    print (
        "\nFor model %d the following rate constants have been stored:"
        %mecnum)

    ndisp = 0
    for i in range(len(meclist)):
       if meclist[i][1] == mecnum:
           print (i+1), meclist[i][3]
           ndisp += 1
           if ndisp % 20 == 0:
               raw_input("\n   Hit ENTER for more... \n")
    try:
        ratenum = (int(raw_input(
            "\nWhich rate set would you like to read?... ")) - 1)
    except:
        print "Error: rate set number not entered!"

    if (ratenum < 0) or (ratenum > len(meclist)):
        print "Error: not valid rate set number!"

    return mecnum, ratenum

def mec_load(mecfile, start):
    """
    Load chosen mec.

    Parameters
    ----------
    mecfile : filename
    start : int
        Start byte in mecfile for mechanism to read.

    Returns
    -------
    mec.Mechanism(RateList, StateList, ncyc) : instance of Mechanism class.
    """

    # Make dummy arrays to read floats, integers and short integers.
    doubles = array('d')
    floats = array ('f')
    ints = array('i')

    f=open(mecfile, 'rb')	# open the .mec file as read only
    f.seek(start - 1);
    ints.fromfile(f, 1)
    version1 = ints.pop()
    ints.fromfile(f, 1)
    mecnum = ints.pop()
    mectitle = f.read(74);

    # Read number of states.
    ints.fromfile(f,1)
    k = ints.pop()
    ints.fromfile(f,1)
    kA = ints.pop()
    ints.fromfile(f,1)
    kB = ints.pop()
    ints.fromfile(f,1)
    kC = ints.pop()
    ints.fromfile(f,1)
    kD = ints.pop()

    # In mec files version=103 all shut states are of type 'C'.
    # Check and leave just one in state 'C', others go as 'B'.
    if kB == 0:
        kB = kC - 1
        kC = 1

    ratetitle = f.read(74)

    # Read size of chess board to draw mechanism.
    ints.fromfile(f,1)
    ilast = ints.pop()
    ints.fromfile(f,1)
    jlast= ints.pop()

    # nrateq- number of non-zero rates in Q; = 2*ncon (always)
    ints.fromfile(f,1)
    nrateq = ints.pop()

    # Number of connections.
    ints.fromfile(f,1)
    ncon = ints.pop()

    # Number of concentration dependent rates
    ints.fromfile(f,1)
    ncdep = ints.pop()

    # Number of ligands
    ints.fromfile(f,1)
    nlig = ints.pop()

    # ? if char mechanism is presnt
    ints.fromfile(f,1)
    chardef = ints.pop()

    # ???
    ints.fromfile(f,1)
    boundef = ints.pop()

    # Number of cycles.
    ints.fromfile(f,1)
    ncyc = ints.pop()

    # Voltage.
    floats.fromfile(f,1)
    vref = floats.pop()
#    print 'vref=', vref

    # Number of voltage dependent rates.
    ints.fromfile(f,1)
    nvdep = ints.pop()

    # ???
    ints.fromfile(f,1)
    kmfast = ints.pop()

    # Independent subunit model.
    # False for all old models (npar=nrateq=2*ncon)
    # True when npar < nrateq=2*ncon. In this case must have nsetq>0
    ints.fromfile(f,1)
    indmod = ints.pop()

    # Number of basic rates constants.
    # Normally npar=nrateq and nsetq=0, but when indmod=T then npar<nrateq.
    ints.fromfile(f,1)
    npar = ints.pop()

    # ???
    ints.fromfile(f,1)
    nsetq = ints.pop()

    # ???
    ints.fromfile(f,1)
    kstat = ints.pop()

    # Output of mechanism in characters
    # TODO clean characters
    Jch = []
    for j in range(0, jlast):
        Ich = []
        for i in range(0, ilast):  # 500 is max
             charmod = f.read(2)
             Ich.append(charmod)
        Jch.append(Ich)
    for i in range(0,ilast):
        IIch = []
        for j in range(0, jlast):
            IIch.append(Jch[j][i])
        print ''.join(IIch)

    # Read rate constants.
    irate = []
    for i in range(nrateq):
        ints.fromfile(f,1)
        irate.append(ints.pop())
    jrate = []
    for i in range(nrateq):
        ints.fromfile(f,1)
        jrate.append(ints.pop())
    QT = np.zeros((k, k), 'float64')
    for i in range(nrateq):
        doubles.fromfile(f, 1)
        QT[irate[i]-1, jrate[i]-1] = doubles.pop()
    ratename = []
    for i in range(npar):
        ratename.append(f.read(10))
        #print ratename[i], "QT[",irate[i],",",jrate[i],"]=", QT[irate[i]-1,jrate[i]-1]

    # Read ligand name and ligand molecules bound in each state.
    for j in range(0, nlig):
        ligname = f.read(20)
        #print "Number of ligand %s molecules bound to states:" %ligname
    nbound = np.zeros((nlig,k), 'int32')
    for i in range(nlig):
        for j in range(k):
            ints.fromfile(f, 1)
            nbound[i,j] = ints.pop()
        #print "to state",j+1,":",nbound[i,j]

    # Read concentration dependent rates.
    # from state
    ix = []
    for i in range(0, ncdep):
        ints.fromfile(f,1)
        ix.append(ints.pop())
    # to state
    jx = []
    for j in range(0, ncdep):
        ints.fromfile(f,1)
        jx.append(ints.pop())
        #if verbose: print "jx[",j,"]=",jx[j]
    # ligand bound in that particular transition
    il = []
    for i in range(0, ncdep):
        ints.fromfile(f,1)
        il.append(ints.pop())
        #if verbose: print "il[", i, "]=", il[i]

    # Read open state conductance.
    dgamma = []
    for j in range(0, kA):
        doubles.fromfile(f,1)
        dgamma.append(doubles.pop())
#    print 'dgamma=', dgamma

    # Get number of states in each cycle and connections.
    nsc = np.zeros(50, 'int32')
    for i in range(0, ncyc):
        ints.fromfile(f,1)
        nsc[i] = ints.pop()
    #print "nsc[", i, "]=", nsc[i]
    im = np.zeros((50, 100), 'int32')
    for i in range(0, ncyc):
        for j in range(0, nsc[i]):
            ints.fromfile(f,1)
            im[i, j] = ints.pop()
            #print "im[",i,",",j,"]=",im[i,j]
    jm = np.zeros((50,100), 'int32')
    for i in range(0, ncyc):
        for j in range(0, nsc[i]):
            ints.fromfile(f,1)
            jm[i,j] = ints.pop()
            #print "jm[",i,",",j,"]=",jm[i,j]

    # Read voltage dependent rates.
    # from state
    iv = []
    for i in range(0, nvdep):
        ints.fromfile(f,1)
        iv.append(ints.pop())
        #print "iv[",i,"]=",iv[i]
    # to state
    jv = []
    for j in range(0, nvdep):
        ints.fromfile(f,1)
        jv.append(ints.pop())
        #print "jv[", j,"]=",jv[j]

    hpar = []
    for i in range(0, nvdep):
        floats.fromfile(f,1)
        hpar.append(floats.pop())
        #print "hpar[",i,"]=",hpar[i]

    pstar = []
    for j in range(0, 4):
        floats.fromfile(f,1)
        pstar.append(floats.pop())
        #print "pstar[",j,"]=",pstar[j]

    kmcon = []
    for i in range(0, 9):
        ints.fromfile(f,1)
        kmcon.append(ints.pop())
        #print "kmcon[",i,"]=",kmcon[i]

    ieq = []
    for i in range(0, nsetq):
        ints.fromfile(f,1)
        ieq.append(ints.pop())
        #print "ieq[",i,"]=",ieq[i]

    jeq = []
    for j in range(0, nsetq):
        ints.fromfile(f,1)
        jeq.append(ints.pop())
        #print "jeq[", j, "]=", jeq[j]

    ifq = []
    for i in range(0,nsetq):
        ints.fromfile(f,1)
        ifq.append(ints.pop())
        #print "ifq[",i,"]=",ifq[i]

    jfq = []
    for j in range(0, nsetq):
        ints.fromfile(f,1)
        jfq.append(ints.pop())
        #print "jfq[",j,"]=",jfq[j]

    efacq = []
    for i in range(0, nsetq):
        floats.fromfile(f,1)
        efacq.append(floats.pop())
        #print "efacq[",i,"]=",efacq[i]

    statenames = []
    for i in range(0, kstat):
        statename = f.read(10)
        statenames.append(statename.split()[0])
        #print "State name:", statename
    print "\n"

    ints.fromfile(f,1)
    nsub = ints.pop()
    ints.fromfile(f,1)
    kstat0 = ints.pop()
    ints.fromfile(f,1)
    npar0 = ints.pop()
    ints.fromfile(f,1)
    kcon = ints.pop()
    ints.fromfile(f,1)
    npar1 = ints.pop()
    ints.fromfile(f,1)
    ncyc0 = ints.pop()

    f.close()

    StateList = []
    j = 0
    for i in range(kA):
        StateList.append(dcpyps.State('A', statenames[j], dgamma[j]))
        j += 1
    for i in range(kB):
        StateList.append(dcpyps.State('B', statenames[j], 0))
        j += 1
    for i in range(kC):
        StateList.append(dcpyps.State('C', statenames[j], 0))
        j += 1
    for i in range(kD):
        StateList.append(dcpyps.State('D', statenames[j], 0))
        j += 1

    RateList = []
    for i in range(nrateq):
        cdep = False
        bound = None
        for j in range(ncdep):
            if ix[j] == irate[i] and jx[j] == jrate[i]:
                cdep = True
                bound = 'c'
        rate = QT[irate[i] - 1, jrate[i] - 1]
        # REMIS: please make sure the state indexing is correct
        RateList.append(dcpyps.Rate(rate, StateList[irate[i]-1],
            StateList[jrate[i]-1], name=ratename[i], eff=bound))

    CycleList = []
    for i in xrange(ncyc):
#        mrconstrained = False
        CycleStates = []
        for j in xrange(nsc[i]):
            CycleStates.append(statenames[im[i, j]-1])
        CycleList.append(dcpyps.Cycle(CycleStates))

    return dcpyps.Mechanism(RateList, CycleList,
        mtitle=mectitle, rtitle=ratetitle)

def mec_load_from_prt(filename, verbose=False):    
    f = open(filename, 'r')
    linenum = 0
    
    
    ncyc, nsc, im2, jm2, mr = 0, [], [], [], []
    states, conductance, ligbound = [], [], []
    tres, tcrit, CHS = [], [], []
    rates, constrained = [], []
    k, kA, kB, kC, kD = 0, 0, 0, 0, 0

    f.readline()
    line = f.readline()
    if "Program HJCFIT Windows Version (Beta)" in line:
        version = 'win'
    else:
        version = 'dos'
    if verbose: print 'version=', version

    while True:
        try:
            line = f.readline()
            #print 'line:', line
            if line == '':
                break
            line = line.strip("\r\n")
            linenum += 1
        except EOFError:
            print('MOD reading finished.')
            
        if "HJCFIT: Fit of model to open-shut times with missed events" in line:
            if verbose: print 'This is possibly HJCFIT printout file.'
            
        if "No of states in each subset: kA, kB, kC, kD =" in line:
            kA = int(line.split()[-4].strip())
            kB = int(line.split()[-3].strip())
            kC = int(line.split()[-2].strip())
            kD = int(line.split()[-1].strip())
            k = kA + kB + kC + kD
            if verbose: print ("Number of states: kA, kB, kC, kD = {0:d}, {1:d}, {2:d}, {3:d}".
                format(kA, kB, kC, kD))

        if version == 'win' and "Number of open states =" in line and k == 0:
            kA = int(line.split()[-1].strip())
            line = f.readline()
            while line != "\n":
                conductance.append(float(line.split()[-1].strip()))
                line = f.readline()
            k = len(conductance)
            kB = k - kA - 1
            kC = 1
            kD = 0
            if verbose: print ("Number of states: kA, kB, kC, kD = {0:d}, {1:d}, {2:d}, {3:d}".
                format(kA, kB, kC, kD))
            
        if "Number of ligands =" in line:
            nlig = int(line.split()[-1].strip())
            if verbose: print "Number of ligands = {0:d}".format(nlig)
            f.readline() #'Concentration-dependent elements:'
            f.readline() #'  i   j     ligand #   Ligand name'
            line = f.readline()
            im, jm, lig = [], [], []
            while line != "\n":
                temp = line.split()
                im.append(int(temp[0]))
                jm.append(int(temp[1]))
                lig.append(temp[-1])
                line = f.readline()
            if verbose: print "im=", im
            if verbose: print "jm=", jm
            if verbose: print "lig=", lig
                
        
        if (version == 'dos') and ("Cycle #" in line) and (int(line[-1]) > ncyc):
            c1, c2 = [], []
            ncyc += 1
            line = f.readline()
            temp = line.split()
            c1.append(int(temp[1].strip(',')))
            c2.append(int(temp[2].strip(')')))
            mr.append([int(temp[1].strip(',')), int(temp[2].strip(')'))])
            line = f.readline()
            temp = line.split()
            while temp:
                c1.append(int(temp.pop(0).strip('-')))
                c2.append(int(temp.pop(0)))
            nsc.append(len(c1))
            im2.append(c1)
            jm2.append(c2)
            if verbose: print "Cycle # ", ncyc
            if verbose: print nsc
            if verbose: print im2, jm2

        if (version == 'win') and ("Microscopic reversibility" in line):
            line = f.readline()
            while "cycle=" in line:
                c1, c2 = [], []
                ncyc += 1
                temp = line.strip(';').split()
                nsc.append(len(temp[3].strip()))
                temp = temp[7:]
                for item in temp:
                    c1.append(int(item.strip(';')))
                im2.append(c1)
                line = f.readline()

        if (version == 'win') and ("by microscopic reversibility" in line):
            if len(mr) < ncyc:
                temp = []
                temp.append(int(line[3:5].strip()))
                temp.append(int(line[6:8].strip()))
                mr.append(temp)
            
#        if "state #    state name" in line: # in 'dos'
#            line = f.readline()
#            while line != "\n":
#                temp = line.split()
#                states.append(temp[1])
#                line = f.readline()
#            if len(states) == k:
#                if verbose: print states
#            else:
#                print "Warning: number of states does not correspond."
                
        if "Number of ligands bound" in line:
            line = f.readline()
            line = f.readline()     
            while len(states) < k:
                temp = line.split()
                if len(temp) == 3:
                    states.append(temp[1])
                    ligbound.append(int(temp[2]))
                line = f.readline()
            if verbose: print 'states: ', states
            if verbose: print 'ligandsbound=', ligbound
                
        if "Resolution for HJC calculations" in line:
            line = f.readline()
            while line != "\n":
                temp = line.split()
                if len(temp) == 4:
                    tres.append(float(temp[2]) * 1e-6)
                line = f.readline()
            if verbose: print 'resolution: ', tres
            
        if "The following parameters are constrained:" in line:
            line = f.readline()
            while '-----' not in line:
                cnstr = []
                temp = line.split()
                r1 = int(temp[1]) - 1
                line = f.readline()
                temp = line.split()
                fac = float(temp[0])
                op = temp[1]
                r2 = int(temp[3]) - 1
                cnstr.append(r1)
                cnstr.append(op)
                cnstr.append(fac)
                cnstr.append(r2)
                line = f.readline()
                constrained.append(cnstr)
#            print constrained
            
        if (version == 'dos') and ("initial        final" in line):
            line = f.readline()
            while line != "\n":
                rate = []
                if 'q(' in line:
                    rate.append(int(line[8:10].strip()))
                    rate.append(int(line[11:13].strip()))
                    rate.append(line[18:29].strip())
                    rate.append(float(line[42:55].strip()))
                    if len(line) > 55:
                        rate.append(line[55:].strip().strip('(').strip(')'))
                rates.append(rate)
                line = f.readline()
            if constrained:
                for item in constrained:
                    if len(rates[item[0]]) > 4: # and rates[item[0, 4]] == 'constrained':
                        rates[item[0]].append(item[1])
                        rates[item[0]].append(item[2])
                        rates[item[0]].append(item[3])
            if verbose: print rates
            
        if (version == 'win') and ("initial        final" in line):
            while len(rates) < numrates:
                rate = []
                line = f.readline()
                while line != "\n":
                    rate.append(int(line[8:10].strip()))
                    rate.append(int(line[11:13].strip()))
                    rate.append(line[18:29].strip())
                    rate.append(float(line[42:55].strip()))
                    rates.append(rate)
                    line = f.readline()
                    if line != "\n":
                        rates[-1].append(line.strip().strip('(').strip(')'))
                        line = f.readline()
            
        if 'Total number of rates' in line:
            numrates = int(line.split()[-1])
            numfixed = int(f.readline().split()[-1])
            numconstr = int(f.readline().split()[-1])
            nummr = int(f.readline().split()[-1])
            numec50 = int(f.readline().split()[-1])
            numfree = int(f.readline().split()[-1])
            if verbose: print ('\nTotal number of rates = {0:d}'.format(numrates) +
                '\nNumber that are fixed       = {0:d}'.format(numfixed) +
                '\nNumber that are constrained = {0:d}'.format(numconstr) +
                '\nNumber set by micro rev     = {0:d}'.format(nummr) +
                '\nNumber set by fixed EC50    = {0:d}'.format(numec50) +
                '\nNumber of free rates to be estimated = {0:d}'.format(numfree))

    if verbose: print 'file contains {0:d} lines'.format(linenum)
    f.close()
    
    StateList = []
    j = 0
    for i in range(kA):
        StateList.append(dcpyps.State('A', states[j], 50))
        j += 1
    for i in range(kB):
        StateList.append(dcpyps.State('B', states[j], 0))
        j += 1
    for i in range(kC):
        StateList.append(dcpyps.State('C', states[j], 0))
        j += 1
    for i in range(kD):
        StateList.append(dcpyps.State('D', states[j], 0))
        j += 1
        
    RateList = []
    for i in range(numrates):
        bound = None
        mrc = False
        is_constr = False
        constr_func = None
        constr_args = None
        for j in range(len(im)):
            if im[j] == rates[i][0] and jm[j] == rates[i][1]:
                bound = 'c'
        for j in range(ncyc):
            if mr[j][0] == rates[i][0] and mr[j][0] == rates[i][1]:
                mrc = True
        if len(rates[i]) > 5 and rates[i][4] == 'constrained':
            is_constr = True
            if rates[i][5] == 'times':
                constr_func = mechanism.constrain_rate_multiple
                constr_args = [rates[i][7], rates[i][6]]
        
        rate = rates[i][3]
        # REMIS: please make sure the state indexing is correct
        RateList.append(dcpyps.Rate(rate, StateList[rates[i][0]-1],
            StateList[rates[i][1]-1], name=rates[i][2], eff=bound, mr=mrc,
            is_constrained=is_constr, constrain_func=constr_func, constrain_args=constr_args))
            
    CycleList = []
    for i in range(ncyc):
#        mrconstrained = False
        CycleStates = []
        for j in range(nsc[i]):
            CycleStates.append(states[im2[i][j]-1])
        CycleList.append(dcpyps.Cycle(CycleStates))

    return dcpyps.Mechanism(RateList, CycleList)

def mod_load(file):
    """
    Load mechanism from Channel Lab .mod file.

    Parameters
    ----------
    file : filename

    Returns
    -------
    mec.Mechanism(RateList, StateList, ncyc) : instance of Mechanism class.
    """

    # TODO: get cycles from mod file.
    f = open(file, 'r')	# open the .mec file as read only
    cl = f.readline().strip("\n")
    #print cl
    modtitle = f.readline().strip("\n")
    #print modtitle

    while True:
        try:
            line = f.readline()
            #print 'line:', line
            if line == '':
                break
            line = line.strip("\r\n")
        except EOFError:
            print('MOD reading finished.')

        if line == '[State1-20: labels]':
            statelabels = []
            for i in range(20):
                statelabels.append(f.readline().strip("\r\n"))
#            print statelabels

        if line == '[State1-20: onoff]':
            stateonoff = np.empty((20, 4))
            for i in range(20):
                onoff = f.readline().strip("\r\n")
                values = onoff.split(' ')
                stateonoff[i, 0] = int(values[0])
                stateonoff[i, 1] = int(values[1])
                stateonoff[i, 2] = float(values[2])
                stateonoff[i, 3] = float(values[3])
#            print stateonoff

        if line == '[Drug dependence labels]':
            druglabels = []
            for i in range(6):
                druglabels.append(f.readline().strip("\r\n"))
#            print druglabels

        if line == '[K1-31on]':
            kon = np.empty(31)
            for i in range(31):
                kon[i] = float(f.readline().strip("\r\n"))
#            print kon

        if line == '[K1-31off]':
            koff = np.empty(31)
            for i in range(31):
                koff[i] = float(f.readline().strip("\r\n"))
#            print koff

        if line == '[Kon concentration/voltage dependent]':
            konconc = np.empty((31, 7))
            for i in range(31):
                onconc = f.readline().strip("\r\n")
                values = onconc.split(' ')
                for j in range(7):
                    konconc[i, j] = int(values[j])
#            print konconc

        if line == '[Koff concentration/voltage dependent]':
            koffconc = np.empty((31, 7))
            for i in range(31):
                offconc = f.readline().strip("\r\n")
                values = offconc.split(' ')
                for j in range(7):
                    koffconc[i, j] = int(values[j])
#            print koffconc

        # [Rate constants for transitions between all states]
        # [Constraints for rate constants for transitions]
        # [Loop Constraints for rate constants for transitions]

        # [Kon steepness of voltage dependence]
        # [Kon activation range for voltage dependence]
        # [Koff steepness of voltage dependence]
        # [Koff activation range for voltage dependence]
        # [QMatrixMonteCarlo,#passes,#pts,#start,#channels,openstate,startstate,pApS,mVmM]
        # [extra storage space]
        # [adinterval,conductance,voltage,vrev,valence,kzero]
        # [Stimulus: Mode,AutoStep,ManualStep,Exp,Fc,pole,autofilt]
        # [Analysis: pksrch,pkave,basepts,basepos,startpos,risebeg,riseend]
        # [Analysis: expmodel,parse,numfitpts,numiter,numrestarts,tol,dual,startpts]
        # [Analysis: Fit limits hi,lo for vertex 1-72]
        # [Analysis: Fixed fit params for vertex 1-72]
        # [Analysis: Seeds for vertex 1-72, fitlims,autoseed,fixfree]
        # [FitWaveforms: start, stop positions for fit]
        # [Multi-stimulus file voltage / concentration parameters]
        # 20 [TState1-20: labels]

    f.close()

    StateList = []
    statesA = []
    statesB = []
    statesC = []
    for i in range(stateonoff.shape[0]):
        if stateonoff[i, 0] == 1:
            if stateonoff[i, 1] == 1:
                statesA.append(i)
            elif stateonoff[i, 3] == 1:
                statesC.append(i)
            else:
                statesB.append(i)
    newstates = []
    newstates.extend(statesA)
    newstates.extend(statesB)
    newstates.extend(statesC)
    k = len(newstates)

    for i in range(k):
            if stateonoff[newstates[i], 1] == 1:
                StateList.append(dcpyps.State('A',
                    statelabels[newstates[i]], stateonoff[newstates[i], 2]))
            elif stateonoff[newstates[i], 3] == 1:
                StateList.append(dcpyps.State('C',
                    statelabels[newstates[i]], 0))
            else:
                StateList.append(dcpyps.State('B',
                    statelabels[newstates[i]], 0))

    RateList = []
    for i in range(k):
        li = (newstates[i]+1) // 5
        ci = (newstates[i]+1) % 5

        bound = None
        if newstates[i] != max(newstates):
            if (newstates[i] > 14) and (newstates[i] < 19):
                # States 16-19.
                ri = 9 * li + ci - 1
                if (kon[ri] != 0) or (koff[ri] != 0):
                    if konconc[ri1, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(kon[ri1],
                        StateList[i],
                        StateList[newstates.index(newstates[i]+1)],
                        name='k'+str(i)+str(newstates.index(newstates[i]+1)),
                        eff=bound))
                    if koffconc[ri1, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(koff[ri1],
                        StateList[newstates.index(newstates[i]+1)],
                        StateList[i],
                        name='k'+str(newstates.index(newstates[i]+1))+str(i),
                        eff=bound))

            elif ci == 0:
                # States 5, 10, 15
                ri = 9 * li + ci + 4 - 1
                if (kon[ri] != 0) or (koff[ri] != 0):
                    if konconc[ri, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(kon[ri],
                        StateList[i],
                        StateList[newstates.index(newstates[i]+5)],
                        name='k'+str(i)+str(newstates.index(newstates[i]+5)),
                        eff=bound))
                    if koffconc[ri, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(koff[ri],
                        StateList[newstates.index(newstates[i]+5)],
                        StateList[i],
                        name='k'+str(newstates.index(newstates[i]+5))+str(i),
                        eff=bound))

            else:
                # States 1-4, 6-9, 11-14
                ri1 = 9 * li + ci - 1
                ri2 = 9 * li + ci + 4 - 1

                if (kon[ri1] != 0) or (koff[ri1] != 0):
                    if konconc[ri1, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(kon[ri1],
                        StateList[i],
                        StateList[newstates.index(newstates[i]+1)],
                        name='k'+str(i)+str(newstates.index(newstates[i]+1)),
                        eff=bound))
                    if koffconc[ri1, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(koff[ri1],
                        StateList[newstates.index(newstates[i]+1)],
                        StateList[i],
                        name='k'+str(newstates.index(newstates[i]+1))+str(i),
                        eff=bound))

                if (((kon[ri2] != 0) or (koff[ri2] != 0)) and
                    ((newstates[i]+5) <= max(newstates))):
                    if konconc[ri2, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(kon[ri2],
                        StateList[i],
                        StateList[newstates.index(newstates[i]+5)],
                        name='k'+str(i)+str(newstates.index(newstates[i]+5)),
                        eff=bound))
                    if koffconc[ri2, 0] == 1:
                        bound = 'c'
                    else:
                        bound = None
                    RateList.append(dcpyps.Rate(koff[ri2],
                        StateList[newstates.index(newstates[i]+5)],
                        StateList[i],
                        name='k'+str(newstates.index(newstates[i]+5))+str(i),
                        eff=bound))

    return dcpyps.Mechanism(RateList, mtitle=modtitle), modtitle

def scn_read_header (fname):
    """
    Read SCN file header. SCN files are generated by SCAN program (DCprogs) and
    contain idealised single channel record.
    """

    # make dummy arrays to read floats, doubles and integers (LONG in C)
    floats = array ('f')
    ints = array('i')
    doubles = array('d')

    f = open(fname, 'rb')
    header = {}

    ints.fromfile(f,1)
    header['iscanver'] = ints.pop()
    # new scan files- version 104, 103 (simulated) and -103
    version = header['iscanver']
    #print 'version', version

    ints.fromfile(f,1)
    ioffset = ints.pop()
    header['ioffset'] = ioffset

    ints.fromfile(f,1)
    nint = ints.pop()
    header['nint'] = nint

    header['title'] = f.read(70)
    header['date'] = f.read(11)

    if version == -103:
        header['tapeID'] = f.read(24)
        ints.fromfile(f,1)
        header['ipatch'] = ints.pop()
        floats.fromfile(f,1)
        header['Emem'] = floats.pop()
        ints.fromfile(f,1)
        header['unknown1'] = ints.pop()
        floats.fromfile(f,1)
        header['avamp'] = floats.pop()
        floats.fromfile(f,1)
        header['rms'] = floats.pop()
        floats.fromfile(f,1)
        header['ffilt'] = floats.pop()
        floats.fromfile(f,1)
        calfac2 = floats.pop()
        header['calfac2'] = calfac2
        floats.fromfile(f,1)
        header['treso'] = floats.pop()
        floats.fromfile(f,1)
        header['tresg'] = floats.pop()

        f.close()
        return ioffset, nint, calfac2, header

    header['defname'] = f.read(6)
    header['tapeID'] = f.read(24)
    ints.fromfile(f,1)
    header['ipatch'] = ints.pop()
    ints.fromfile(f,1)
    header['npatch'] = ints.pop()
    floats.fromfile(f,1)
    header['Emem'] = floats.pop()
    floats.fromfile(f,1)
    header['temper'] = floats.pop()
    header['adcfil'] = f.read(30)
    header['qfile1'] = f.read(35)

    # logical; true if data from CJUMP file
    ints.fromfile(f,1)
    header['cjump'] = ints.pop()

    ints.fromfile(f,1)
    header['nfits'] = ints.pop()

    ints.fromfile(f,1)
    header['ntmax'] = ints.pop()

    ints.fromfile(f,1)
    header['nfmax'] = ints.pop()

    # Number of data points read into memory at each disk read -bigger
    # the better (max depends on how much RAM you have).
    # nbuf=131072		!=1024*128
    ints.fromfile(f,1)
    header['nbuf'] = ints.pop()

    # Number of extra points read in, at each end of data section to
    # allow display of transitions on section boundaries; 2048 is OK usually.
    ints.fromfile(f,1)
    header['novlap'] = ints.pop()

    # Sample rate (Hz)
    floats.fromfile(f,1)
    header['srate'] = floats.pop()

    # finter = microsec between data points; finter=1.e6/srate
    floats.fromfile(f,1)
    header['finter'] = floats.pop()

    # TSECT=time (microsec) from first point of one section to first point of next
    # tsect=float(nbuf)*finter
    floats.fromfile(f,1)
    header['tsect'] = floats.pop()

    # The first data point in data file, idata(1) starts at byte (record #) ioff+1
    ints.fromfile(f,1)
    header['ioff'] = ints.pop()

    ints.fromfile(f,1)
    header['ndat'] = ints.pop()

    # calc nsec etc here, in case default nbuf altered
    # if(ndat.lt.nbuf) nbuf=ndat    !allocate smaller array
    # nsec= 1 + (ndat-1)/nbuf  !number of sections
    ints.fromfile(f,1)
    header['nsec'] = ints.pop()

    # nrlast=ndat - (nsec-1)*nbuf  !number of idata in last section
    ints.fromfile(f,1)
    header['nrlast'] = ints.pop()

    floats.fromfile(f,1)
    header['avtot'] = floats.pop()

    ints.fromfile(f,1)
    header['navamp'] = ints.pop()

    floats.fromfile(f,1)
    avamp = floats.pop()
    header['avamp'] = avamp

    floats.fromfile(f,1)
    rms = floats.pop()
    header['rms'] = rms

    # Data will be written to disk at (approx) every nth transition, so
    # analysis can be restarted by using the ''restart'' option when SCAN reentered.
    ints.fromfile(f,1)
    header['nwrit'] = ints.pop()

    # nwsav=0		!used for auto disc write
    ints.fromfile(f,1)
    header['nwsav'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['newpar'] = ints.pop()

    # logical
    ints.fromfile(f,1)
    header['opendown'] = ints.pop()

    # logical; Invert trace (openings must be downwards)
    ints.fromfile(f,1)
    header['invert'] = ints.pop()

    # logical; usepots=.false.
    ints.fromfile(f,1)
    header['usepots'] = ints.pop()

    # in SCAN: Display only (no step-response function)
    ints.fromfile(f,1)
    header['disp'] = ints.pop()

    # if(iscrit.eq.1): Percentage of full amplitude for critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.2): Multiple of RMS noise to define critical level
    # (Scrit) beyond which transition is deemed to occur.
    # if(iscrit.eq.1): smult=0.14 !scrit=0.14*avamp
    # if(iscrit.eq.2): smult=5. scrit=5.0*rms
    floats.fromfile(f,1)
    header['smult'] = floats.pop()

    ints.fromfile(f,1)
    header['scrit'] = ints.pop()

    ints.fromfile(f,1)
    header['vary'] = ints.pop()

    # Number of consecutive points beyond Scrit for a transition to be
    # deemed to have occurred. Default: ntrig=2
    ints.fromfile(f,1)
    header['ntrig'] = ints.pop()

    # navtest=ntrig-1 ; if(navtest.le.0) navtest=1
    # navtest=number averaged before average curlev is used, rather than
    # input curlev in FINDTRANS (NB must be less than ntrig, or, for
    # example, if input baseline is not close to current baseline
    # (ie baseline has drifted since last time) then will get a 'trigger'
    # straight away!
    ints.fromfile(f,1)
    header['navtest'] = ints.pop()

    # Trace will be amplified by this factor before display (but better to
    # amplify correctly BEFORE sampling). DGAIN=1.0
    floats.fromfile(f,1)
    header['dgain'] = floats.pop()

    # IBOFF=0		!BASELINE OFFSET FOR DISPLAY (ADC)
    ints.fromfile(f,1)
    header['iboff'] = ints.pop()

    # Factor by which trace is expanded when ''expand'' is first hit.
    # expfac=2.
    floats.fromfile(f,1)
    header['expfac'] = floats.pop()

    # Position of baseline on screen is offset to this level after initial
    # ''get piece of baseline on screen'' is completed.
    # bdisp=0.75 if openings downwards; bdisp=0.25 if openings upwards
    floats.fromfile(f,1)
    header['bdisp'] = floats.pop()

    ints.fromfile(f,1)
    header['ibflag'] = ints.pop()

    # Auto-fit to avoid sublevels if possible. In case of doubt fit brief
    # open-shut-open rather than fitting a sublevel.
    ints.fromfile(f,1)
    header['iautosub'] = ints.pop()

    # When opening crosses the red trigger line display stops with the
    # opening transition at this point on the x-axis of display.
    # xtrig=0.2: trigger at 20% of X axis on screen
    floats.fromfile(f,1)
    header['xtrig'] = floats.pop()

    # ndev='C:'; disk partition for Windows
    header['ndev'] = f.read(2)
    header['cdate'] = f.read(11)
    header['adctime'] = f.read(8)

    ints.fromfile(f, 1)
    header['nsetup'] = ints.pop()

    header['filtfile'] = f.read(20)

    # Low pass filter (Hz, -3dB)
    # later needs to be converted to kHz
    floats.fromfile(f, 1)
    ffilt = floats.pop()
    header['ffilt'] = ffilt

    # npfilt=number of points to jump forward after a transition, to start
    # search for next transition
    # npfilt1= number of data points for filter to go from 1% to 99%
    # npfilt1=ifixr((tf99-tf1)/finter)
    # npfilt=ifixr(float(npfilt1)*facjump)
    ints.fromfile(f, 1)
    header['npfilt'] = ints.pop()

    # sfac1=(yd2-yd1)/65536.
    # sfac1=sfac1*dgain			!true scal fac for ADC to pixel units
    floats.fromfile(f, 1)
    header['sfac1'] = floats.pop()

    # nscale=1 + ifix(alog(4096./(yd2-yd1))/alog(2.))
    # sfac2=sfac1*float(2**nscale)	!Converts ADC units to intermed units
    floats.fromfile(f, 1)
    header['sfac2'] = floats.pop()

    # sfac3=1.0/float(2**nscale) 	!converts intermed to pixel units
    floats.fromfile(f, 1)
    header['sfac3'] = floats.pop()

    ints.fromfile(f, 1)
    header['nscale'] = ints.pop()

    # Calibration factor (pA per ADC unit)
    floats.fromfile(f, 1)
    header['calfac'] = floats.pop()

    # calfac1=calfac/sfac1		!converts pixel display units to pA
    floats.fromfile(f, 1)
    header['calfac1'] = floats.pop()

    # calfac2=calfac/sfac2		!converts intermed units to pA
    floats.fromfile(f, 1)
    calfac2 = floats.pop()
    header['calfac2'] = calfac2

    # iyoff=ifixr(yd1 + 0.5*(yd2-yd1))	!zero in centre until baseline done
    # (NB iyoff is in pixel units)
    ints.fromfile(f, 1)
    header['iyoff'] = ints.pop()

    ints.fromfile(f, 1)
    header['ioff1'] = ints.pop()

    # Show position of guessed transition points on screen as purple line
    # + blue line to mark end of transition.
    ints.fromfile(f, 1)
    header['disptran'] = ints.pop()

    # When first derivative used to identify two closely-spaced
    # transitions, display it below the trace.
    ints.fromfile(f, 1)
    header['dispderiv'] = ints.pop()

    # dispguess=.true.
    ints.fromfile(f, 1)
    header['dispguess'] = ints.pop()

    # Amplitude difference (as fraction of full amp) below which openings
    # are deemed to have ''same'' amplitude: for (a) elim of short gaps
    # (b) setting guesses. ampfac=0.05
    floats.fromfile(f, 1)
    header['ampfac'] = floats.pop()

    # Length of fitted event (microsec) below which refit, omitting short
    # events, is offered.  Events guessed to be shorter than this are
    # rejected before fitting. tmin=15
    floats.fromfile(f, 1)
    header['tmin'] = floats.pop()

    # Length (multiple of risetime) of event below which its amplitude is
    # fixed (also length guessed from peak amplitude).
    # tsfac=2.0		!tsfac*trise=tshort
    floats.fromfile(f, 1)
    header['tsfac'] = floats.pop()

    # Length (multiple of risetime) of event above which amplitude is
    # ''well-defined'' so usable to fix length of an adjacent brief opening.
    # tlfac=3.0		!tlfac*trise=tlong
    floats.fromfile(f, 1)
    header['tlfac'] = floats.pop()

    # sdone=.false.	!no baseline SD yet -NO -set BEFORE INSCAN
    ints.fromfile(f, 1)
    header['sdone'] = ints.pop()

    # real*8 in fortran;double precizion value of finter
    # Need double prec versions of finter if time of transition from 1st point
    # in CONSAM to be recorded accurately (see FITSUB).  At present, cannot
    # have smaller finter than 0.25 microsec (with 4 MHz clock) so want to get
    # rid of non sig figs when DBLE(finter) is calc
    doubles.fromfile(f, 1)
    header['dfinter'] = doubles.pop()

    doubles.fromfile(f, 1)
    header['tlast'] = doubles.pop()

    ints.fromfile(f, 1)
    header['shut'] = ints.pop()

    ints.fromfile(f, 1)
    header['shutprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['backward'] = ints.pop()

    ints.fromfile(f, 1)
    header['prevlevel'] = ints.pop()

    floats.fromfile(f, 1)
    header['t0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['y0sav'] = floats.pop()

    floats.fromfile(f, 1)
    header['vard'] = floats.pop()

    # Number of points before first, and after last, transition to be
    # fitted in auto mode. Number of shut points to be fitted at ends.
    # Default: nshutfit=50;
    ints.fromfile(f, 1)
    header['nshutfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infit'] = ints.pop()

    ints.fromfile(f, 1)
    header['infirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['ixfprev'] = ints.pop()

    ints.fromfile(f, 1)
    header['idiskq'] = ints.pop()

    ints.fromfile(f, 1)
    header['ifirst'] = ints.pop()

    ints.fromfile(f, 1)
    header['base'] = ints.pop()

    ints.fromfile(f, 1)
    header['basevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['ibasevga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrig'] = ints.pop()

    ints.fromfile(f, 1)
    header['itrigvga'] = ints.pop()

    ints.fromfile(f, 1)
    header['itriglev'] = ints.pop()

    ints.fromfile(f, 1)
    header['inc'] = ints.pop()

    ints.fromfile(f, 1)
    header['incabs'] = ints.pop()

    ints.fromfile(f, 1)
    header['indfast'] = ints.pop()

    ints.fromfile(f, 1)
    header['isdfst'] = ints.pop()

    ints.fromfile(f, 1)
    header['isec'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp'] = ints.pop()

    ints.fromfile(f, 1)
    header['ndisp1'] = ints.pop()

    #? idatyp=0 for usual CONSAM, idatyp=1 for pdpdata and
    #? idatyp=2 for Axon data
    ints.fromfile(f, 1)
    header['idatyp1'] = ints.pop()

    header['cdate1'] = f.read(11)

    # number of channels in patch
    ints.fromfile(f, 1)
    header['nchan'] = ints.pop()

    # Length (multiple of risetime) of interval between two transitions
    # (in same direction) below which an attempt is made to fit brief
    # events rather than sublevel.
    # tcfac=4.		!tcfac*trise=tclose
    # ''Close'' transitions (multiple of risetime)'	!tclose
    floats.fromfile(f, 1)
    header['tcfac'] = floats.pop()

    # Fraction of step-response (filter) length (1-99%) allowed after a
    # transition before search for next transition is started. facjump=0.6
    floats.fromfile(f, 1)
    header['facjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['shutsav'] = ints.pop()

    ints.fromfile(f, 1)
    header['goback'] = ints.pop()

    ints.fromfile(f, 1)
    header['imin'] = ints.pop()

    ints.fromfile(f, 1)
    header['imax'] = ints.pop()

    # Factor by which initial guess must be reduced before Simplex
    # converges; (e.g. 0.01=low precision; 0.0001=high precision)
    # errfac=0.005
    floats.fromfile(f, 1)
    header['errfac'] = floats.pop()

    # Multiple of SD of 1st deriv used to find inflections; small value
    # e.g. 2.0 makes it more likely that multiple transitions fitted,
    # rather than sublevel. Sensitivity for multiple trans (vs sublevel).
    # derivfac=3.
    floats.fromfile(f, 1)
    header['derivfac'] = floats.pop()

    # Controls how fast the simplex contracts around a putative minimum.
    # Usually 0.5; smaller value (down to 0.2) gives faster convergence
    # but fit may be worse.
    floats.fromfile(f, 1)
    header['confac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nsweep'] = ints.pop()

    # njdim=nsamp/njump
    ints.fromfile(f, 1)
    header['njdim'] = ints.pop()

    doubles.fromfile(f, 1)
    header['tzerod'] = doubles.pop()

    floats.fromfile(f, 1)
    header['intzero'] = floats.pop()

    # real*8 in fortran
    doubles.fromfile(f, 1)
    header['tsample'] = doubles.pop()

    floats.fromfile(f, 1)
    header['ktjump'] = floats.pop()

    ints.fromfile(f, 1)
    header['njfit'] = ints.pop()

    ints.fromfile(f, 1)
    header['njump'] = ints.pop()

    ints.fromfile(f, 1)
    header['nnull'] = ints.pop()

    floats.fromfile(f, 1)
    header['ktlast'] = floats.pop()

    #Default zoom factor (must be an integer power of 2 (i.e. 1,2,4,8...etc)
    ints.fromfile(f, 1)
    header['izoom'] = ints.pop()

    # Filter cut-off (Hz, -3 dB) when zoomed (default = same as input data,
    # i.e. no extra filtering when zoomed)
    floats.fromfile(f, 1)
    header['fcz'] = floats.pop()

    # fczoom=actual fc applied to achieve fcz (in kHz)
    # fczoom=1./sqrt((1.0/(fcz*fcz)) - (1.0/(ffilt*ffilt)))
    floats.fromfile(f, 1)
    header['fczoom'] = floats.pop()

    # ''Full amplitude'' to be used to identify transitions when zoomed
    # (approx size of small channels).
    # avampz=alternative 'full amplitude' to use for event detection
    # when zoomed/filtered (NB use zoomfac=1 or fczoom=filtf to get
    # filtering only or zoom only). avampz in intermed units
    # (same as avamp); ampz=same thing pA
    floats.fromfile(f, 1)
    header['ampz'] = floats.pop()

    floats.fromfile(f, 1)
    header['avampsav'] = floats.pop()

    # No. of iterations done by SIMPLEX before swapping to DFPMIN
    # (Davidon-Fletcher-Powell minimisation) when both used.
    # itsimp=1200
    ints.fromfile(f, 1)
    header['itsimp'] = ints.pop()

    # 1=SIMPLEX only (as before). 2=SIMPLEX for fixed number of iterations,
    # then swap to DFPMIN. 3=Davidon-Fletcher-Powell (DFPMIN) only.
    ints.fromfile(f, 1)
    header['minmeth'] = ints.pop()

    # Minimum # of points at the shut level within a fit required for this
    # shut level to be used to estimate the amplitude of nearby openings.
    # nbasemin=10
    ints.fromfile(f, 1)
    header['nbasemin'] = ints.pop()

    # Definition of threshold for detecting transitions: 1=fraction of
    # mean full amp; 2=multiple of rms noise. (Level is set as
    # parameter 3, page 1).
    # iscrit=1 to use scrit=smult*avamp (recent versions of scan)
    # iscrit=2 to use scrit=smult*rms (as in original version of scan)
    # latter could be better for records with wide range of amps
    ints.fromfile(f, 1)
    header['iscrit'] = ints.pop()

    # Use reduced critical amplitude for detecting transitions when all
    # amplitudes in the fit are smaller than the full amplitude.
    # Use variable critical level (see HELP)
    # default scritvar=.false.
    # if scritvar=true, smaller scrit is used for fittings that have only
    # small amplitudes. In this case value of scrit changed after region
    # to be fitted has been defined, with minimum smult=smultmin
    ints.fromfile(f, 1)
    header['scritvar'] = ints.pop()

    # Minimum crit level when using lower threshold for detecting
    # transitions when all amplitudes in the fit are smaller than the
    # full amplitude (as mult of RMS).
    # smultmin=2.5		!2.5*rms1 in intermed units
    # Minimum critical level (see HELP): multiple of RMS
    floats.fromfile(f, 1)
    header['smultmin'] = floats.pop()

    floats.fromfile(f, 1)
    header['stpfac'] = floats.pop()

    ints.fromfile(f, 1)
    header['nlig'] = ints.pop()

    floats.fromfile(f, 1)
    header['conc1'] = floats.pop()

    f.close() #    close the file

    #return ioffset, nint, calfac2, ffilt, rms, avamp, header
    return ioffset, nint, calfac2, header

def scn_read_data(fname, header):
    """
    Read idealised data- intervals, amplitudes, flags- rom SCN file.

    Data=
    real*4 tint(1...nint) 	 4nint bytes
    integer*2 iampl(1..nint)   2nint bytes
    integer*1 iprops(1..nint)  nint  bytes
    Total storage needed = 7 * nint bytes

    integer*1 iprops(i) holds properties of ith duration and amplitude
    (integer*1 has range -128 to +127 (bit 7 set gives -128; can use bits 0-6)
    0 = all OK;
    1 = amplitude dubious = bit 0;
    2 = amplitude fixed = bit 1;
    4 = amplitude of opening constrained (see fixamp) = bit 2;
    8 = duration unusable = bit 3; etc
    and keep sum of values of more than one property is true.
    """

    tint = array ('f') # 4 byte float
    iampl = array ('h') # 2 byte integer
    iprops = array('b') # 1 byte integer

    f=open(fname, 'rb')
    f.seek(header['ioffset']-1)
    tint.fromfile(f, header['nint'])
    iampl.fromfile(f, header['nint'])
    iprops.fromfile(f, header['nint'])
    f.close()
     
    if header['iscanver'] > 0:
        gapnotfound = True
        while gapnotfound:
            if iampl[-1] == 0:
                gapnotfound = False
                iprops[-1] = 8
            else:
                tint.pop()
                iampl.pop()
                iprops.pop()
        
    return np.array(tint)*0.001, np.array(iampl), np.array(iprops)

def scn_write_simulated(intervals, amplitudes, treso=0.0, tresg=0.0,
        Emem=0.0, avamp = 1.0, filename='SIMSCN.SCN'):
    """
    Write binary SCAN (DCprogs) format file with simulated single channel
    open/shut intervals.

    Parameters
    ----------

    """

    iscanver = -103
    calfac2 = 1.0
    ioffset = 154
    ffilt = -1.0
    rms = 0.0
    title = ('Simulated data                                    ' +
        '                    ')   #character*70
    t = time.asctime()
    expdate = t[8:10] + '-' + t[4:7] + '-' + t[20:24] # '00-ooo-0000' character*11
    tapeID = 'Simulated data          '      #character*24
    ipatch = 0              #integer32
    nint = len(intervals)

    fout = open(filename, 'wb')
    fout.write(struct.pack('i', iscanver))
    fout.write(struct.pack('i', ioffset))
    fout.write(struct.pack('i', nint))
    fout.write(title)
    fout.write(expdate)
    fout.write(tapeID)
    fout.write(struct.pack('i', ipatch))
    fout.write(struct.pack('f', Emem))
    fout.write(struct.pack('i', 0))
    fout.write(struct.pack('f', avamp))
    fout.write(struct.pack('f', rms))
    fout.write(struct.pack('f', ffilt))
    fout.write(struct.pack('f', calfac2))
    fout.write(struct.pack('f', treso))
    fout.write(struct.pack('f', tresg))

    for i in range(0, nint):
        # simulated intervals are in seconds
        # convert to ms; intervals in scn files are kept in ms
        fout.write(struct.pack('f', intervals[i]*1000))
    for i in range(0, nint):
        fout.write(struct.pack('h', amplitudes[i]))
    for i in range(0, nint):
        fout.write(struct.pack('b', 0))
    fout.close()

def scn_write_dummy(data, filename):
    """
    Write binary SCAN (DCprogs) format file. Use this dummy file to plot one
    type of time intervals in EKDIST (DCprogs).
    DCprogs- http://www.ucl.ac.uk/Pharmacology/dcpr95.html

    Parameters
    ----------
    data : list of flotas
        Time intervals in milliseconds.
    file : filename
    """

    iscanver = -103
    nint = None
    calfac2 = 1.0
    ioffset = 154
    ffilt = -1.0
    rms = 0.0
    treso = 0.0
    tresg = 0.0
    title = ('Converted from text file containing one column of intervals.' +
        '          ')   #character*70
    expdate = '00-ooo-0000'    #character*11
    tapeID = 'Converted list          '      #character*24
    ipatch = 0              #integer32
    Emem = 0.0              #float
    avamp = 1.0             #float

    amplitudes = []
    intervals = []
    options = []
    for d in data:
        amplitudes.append(1)
        intervals.append(100)
        options.append(struct.pack("b",0)) ## int8_t
        amplitudes.append(0)
        intervals.append(d)
        options.append(struct.pack("=b",0))
    amplitudes.append(1)
    intervals.append(100)
    options.append(struct.pack("=b",0))
    nint = len(intervals)

    fout = open(filename, 'wb')
    fout.write(struct.pack('i', iscanver))
    fout.write(struct.pack('i', ioffset))
    fout.write(struct.pack('i', nint))
    fout.write(title)
    fout.write(expdate)
    fout.write(tapeID)
    fout.write(struct.pack('i', ipatch))
    fout.write(struct.pack('f', Emem))
    fout.write(struct.pack('i', 0))
    fout.write(struct.pack('f', avamp))
    fout.write(struct.pack('f', rms))
    fout.write(struct.pack('f', ffilt))
    fout.write(struct.pack('f', calfac2))
    fout.write(struct.pack('f', treso))
    fout.write(struct.pack('f', tresg))

    for i in range(0, nint):
        fout.write(struct.pack('f', intervals[i]))
    for i in range(0, nint):
        fout.write(struct.pack('h', amplitudes[i]))
    for i in range(0, nint):
        fout.write(struct.pack('b', 0))

    fout.close()
    print 'Finished writing scn file.'

def abf_read_header (filename, debug=1):
    """
    Read Axon abf file header. Works only for version < 2.0. Read only 
    information required for gap-free data reading.
    """
    
    floats = array ('f')
    ints = array('i')
    shorts = array ('h')
    
    # h- a dictionary containing info from the abf file header
    h = {}

    fid = open(filename, 'rb')

    # read 'fFileSignature' [i.e. abf version) from header
    h['IFileSignature'] = fid.read(4)
    floats.fromfile(fid, 1)
    h['fFileVersionNumber'] = round(floats.pop() * 10) * 0.1
    if debug:
        print 'File signature: ', h['IFileSignature'], h['fFileVersionNumber']

    shorts.fromfile(fid, 1)
    h['nOperationMode'] = shorts.pop()
    if debug:
        if h['nOperationMode'] == 1:
            print("Operation mode 1: event-driven, variable length")
        elif h['nOperationMode'] == 2:
            print("Operation mode 2: oscilloscope, loss free")
        elif h['nOperationMode'] == 3:
            print("Operation mode 3: gap-free")
        elif h['nOperationMode'] == 4:
            print("Operation mode 4: oscilloscope, high-speed")
        elif h['nOperationMode'] == 5:
            print("Operation mode 5: episodic stimulation")
        else:
            print("Operation mode undefined!")

    ints.fromfile(fid, 1)
    h['IActualAcqLength'] = ints.pop()
    if debug:
        print("Actual number of ADC samples = {0:d}".format(h['IActualAcqLength']))

    fid.seek(20)
    ints.fromfile(fid, 1)
    h['IFileStartDate'] = str(ints.pop())
    ints.fromfile(fid, 1)
    h['IFileStartTime'] = str(ints.pop())
    if debug:
        print("Experiment date: " + h['IFileStartDate'])
        print("Experiment time: " + h['IFileStartTime'])

    fid.seek(40)
    ints.fromfile(fid, 1)
    h['IDataSectionPtr'] = ints.pop()
    fid.seek(100)
    shorts.fromfile(fid, 1)
    h['nDataFormat'] = shorts.pop()
    if debug:
        print("Block number of start of Data section = {0:d}".
            format(h['IDataSectionPtr']))
        offset = h['IDataSectionPtr'] * 512
        print("     offset = {0:d}".format(offset))
        print("Data representation (0- short int; 1- float): {0:d}".
            format(h['nDataFormat']))

    fid.seek(120)
    shorts.fromfile(fid, 1)
    h['nADCNumChannels'] = shorts.pop()
    if debug:
        print("Number of analog input channels sampled = {0:d}".
            format(h['nADCNumChannels']))

    floats.fromfile(fid, 1)
    h['fADCSampleInterval'] = floats.pop()
    if debug:
        print("Sampling interval = {0:.1f} microsec".
            format(h['fADCSampleInterval'] * h['nADCNumChannels']))

    fid.seek(244)
    floats.fromfile(fid, 1)
    h['fADCRange'] = floats.pop()
    if debug:
        print("ADC voltage range = {0:.1f} V".format(h['fADCRange']))
    fid.seek(252)
    ints.fromfile(fid, 1)
    h['IADCResolution'] = ints.pop()
    if debug:
        print("Number of ADC counts = {0:d}".format(h['IADCResolution']))

    fid.seek(260)
    shorts.fromfile(fid, 1)
    h['nExperimentType'] = shorts.pop()
    if debug:
        print("Experiment type (0- Voltage-clamp; 1- Current-clamp): {0:d}".
            format(h['nExperimentType']))

    fid.seek(410)
    h['nADCSamplingSeq'] = []
    for i in range(16):
        shorts.fromfile(fid, 1)
        h['nADCSamplingSeq'].append(shorts.pop())
    h['sADCChannelName'] = []
    for i in range(16):
        h['sADCChannelName'].append(fid.read(10))
    h['sADCUnits'] = []
    for i in range(16):
        h['sADCUnits'].append(fid.read(8))
    
    # gains, offsets
    h['fADCProgramableGain'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCProgramableGain'].append(floats.pop())
    h['fADCDisplayAmplification'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCDisplayAmplification'].append(floats.pop())
    h['fADCDisplayOffset'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fADCDisplayOffset'].append(floats.pop())
    h['fInstrumentScaleFactor'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fInstrumentScaleFactor'].append(floats.pop())

    if debug:
        print("Sampled ADC channels, names, units, gain:")
        for i in range(h['nADCNumChannels']):
            print("Channel # {0:d}\t".format(h['nADCSamplingSeq'][i]) +
                h['sADCChannelName'][h['nADCSamplingSeq'][i]] + "\t" +
                h['sADCUnits'][h['nADCSamplingSeq'][i]] + "\t" +
                #"{0:.3f}".format(fADCProgramableGain[nADCSamplingSeq[i]]) + "\t" +
                #"{0:.3f}".format(fADCDisplayAmplification[nADCSamplingSeq[i]]) + "\t" +
                #"{0:.3f}".format(fADCDisplayOffset[nADCSamplingSeq[i]]) + "\t" +
                "{0:.3f}".format(h['fInstrumentScaleFactor'][h['nADCSamplingSeq'][i]]) + " V/" +
                h['sADCUnits'][h['nADCSamplingSeq'][i]])

    fid.seek(1178)
    h['fSignalLowpassFilter'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fSignalLowpassFilter'].append(floats.pop())
    if debug:
        print("Lowpass filter = {0:.1f} Hz".
            format(h['fSignalLowpassFilter'][h['nADCSamplingSeq'][0]]))

    fid.seek(4576)
    h['fTelegraphAdditGain'] = []
    for i in range(16):
        floats.fromfile(fid, 1)
        h['fTelegraphAdditGain'].append(floats.pop())
    if debug:
        print("Additional gain :  {0:.1f}".
            format(h['fTelegraphAdditGain'][h['nADCSamplingSeq'][0]]))
        calfac = (1 / ((h['IADCResolution'] / h['fADCRange'])
            * h['fTelegraphAdditGain'][h['nADCSamplingSeq'][0]] *
            h['fInstrumentScaleFactor'][h['nADCSamplingSeq'][0]]))
        print("Final calfac = {0:.6f}".format(calfac))

    fid.close()
    
    return h # header

def abf_read_data(filename, h):
    """
    Read data from Axon abf file . Works only for version < 2.0.
    """
    
    offset = h['IDataSectionPtr'] * 512
    samples = h['IActualAcqLength'] / h['nADCNumChannels']
    if h['nDataFormat'] == 0:
        data_type = 'h'
    elif h['nDataFormat'] == 1:
        data_type = 'f'
    else:
        print("Can't read data. Data format not defined.")

    fid = open(filename, 'rb')    
    fid.seek(offset)
    
    # Read data block.
    temp = np.fromfile(fid, data_type)
    if h['nADCNumChannels'] > 1:
        temp = np.reshape(temp, (samples, -1))
        channel = temp[:, 0]
    else:
        channel = temp

    fid.close()

    return channel


def ssd_read_header (filename):
    """
    Read the header of a Consam file.
    """
    
    floats = array ('f')
    ints = array('i')
    shorts = array ('h')
    
    # h- a dictionary containing info from the abf file header
    h = {}
    f = open(filename, 'rb')
    
#    if verb: 
#        print("Full header from CONSAM file %s is as follows:" + filename)
#    else:
#        print("Highlights of CONSAM header from %s" + filename)
        
    shorts.fromfile(f,1)
    h['version'] = shorts.pop()
#    if verb: print "Version:", h['version'] # iver =1002 is new, =1001 is old

    h['title'] = f.read(70)
#    print "Title:", h['title']

    h['date'] = f.read(11)
#    if verb: print "Acquisition date:", h['date']

    h['time'] = f.read(8)
    #if verb: print "Acquisition time:", time
 
    shorts.fromfile(f,1)
    h['idt'] = shorts.pop()
#    if verb: print "idt:", idt
 
    ints.fromfile(f,1)
    h['ioff'] = ints.pop()
#    if verb: print "ioff:", ioff

    ints.fromfile(f,1)
    h['ilen'] = ints.pop()
#    if verb:
#        print "ilen:", ilen
#        print 'Attention! ilen gives length in bites, so- number of points is half of ilen'

    shorts.fromfile(f,1)
    h['inc'] = shorts.pop()
#    if verb: print "inc:", inc

    shorts.fromfile(f,1)
    h['id1'] = shorts.pop()
#    if verb: print "id1:", id1

    shorts.fromfile(f,1)
    h['id2'] = shorts.pop()
#    if verb: print "id2:", id2

    h['cs'] = f.read(3)
#    if verb: print "cs:", cs

    floats.fromfile(f,1)
    h['calfac'] = floats.pop()
#    print "calfac:", calfac

    floats.fromfile(f,1)
    h['srate'] = floats.pop()
#    print "Sample frequency: %i Hz" %int (srate)

    floats.fromfile(f,1)
    h['filt'] =floats.pop()
#    print "Filter frequency: %i Hz" %int (filt)

    floats.fromfile(f,1)
    h['filt1'] = floats.pop()
#    if verb: print "filt1:", filt1

    floats.fromfile(f,1)
    h['calfac1'] = floats.pop()
#    if verb: print "calfac1:", calfac1

    h['expdate'] = f.read(11)
#    if verb: print "Experiment date:", expdate

    h['defname'] = f.read(6)
#    if verb: print "defname:", defname

    h['tapeID'] = f.read(24)
#    if verb: print "Tape ID:", tapeID

    ints.fromfile(f,1)
    h['ipatch'] = ints.pop()
#    if verb: print"ipatch:", ipatch

    ints.fromfile(f,1)
    h['npatch'] = ints.pop()
#    if verb: print"npatch:", npatch

    floats.fromfile(f,1)
    h['Emem'] = floats.pop()
#    if verb: print "Transmembrane potential: %i mV" %int (Emem)

    floats.fromfile(f,1)
    h['temp'] = floats.pop()
#    if verb: print "Recording temperature: %i C" %int (temp)

    f.close()
    return h

def ssd_read_data(filename, h):
    """
    Read data from Consam ssd or dat file.
    """

    fid = open(filename, 'rb')
    fid.seek(h['ioff'])
    trace = np.fromfile(fid, 'h')
    fid.close()

    return trace

def ssd_save(filename, h, data):
    """
    Sava data into Consam ssd format file.
    """
    
    fout = open(filename, 'wb')
    
    fout.write(struct.pack('h', 1002))  # version=1002

    k = len(h['title'])  # title size 70 characters
    if k < 70:
        for i in range(k, 70):
            h['title'] += "."
    elif k > 70:
        h['title'] = h['title'][0:70]
    fout.write(h['title'])

    k = len(h['date'])  # date size 11 characters. Format 00-ooo-0000
    if k < 11:
        for i in range(k, 11):
            h['date'] += "."
    elif k > 11:
        h['date'] = h['date'][0:11]
    fout.write(h['date'])
    
    k = len(h['time'])  # time size 8 characters. Format 00-00-00
    if k < 8:
        for i in range(k, 8):
            h['time'] += "."
    elif k > 8:
        h['time'] = h['time'][0:8]
    fout.write(h['time'])

    fout.write(struct.pack('h', h['idt']))
    fout.write(struct.pack('i', h['ioff']))
    fout.write(struct.pack('i', h['ilen']))
    fout.write(struct.pack('h', h['inc']))
    fout.write(struct.pack('h', h['id1']))
    fout.write(struct.pack('h', h['id2']))

    k = len(h['cs'])  # cs size 3 characters. Format abc
    if k < 3:
        for i in range(k, 3):
            h['cs'] += "."
    elif k > 3:
        h['cs'] = h['cs'][0:3]
    fout.write(h['cs'])

    fout.write(struct.pack('f', h['calfac']))
    fout.write(struct.pack('f', h['srate']))  # Sample frequency in Hz
    fout.write(struct.pack('f', h['filt']))  # Filter frequency in Hz
    fout.write(struct.pack('f', h['filt1']))
    fout.write(struct.pack('f', h['calfac1']))

    k = len(h['expdate'])  # date size 11 characters. Format 00-ooo-0000
    if k < 11:
        for i in range(k, 11):
            h['expdate'] += "."
    elif k > 11:
        h['expdate'] = h['expdate'][0:11]
    fout.write(h['expdate'])

    k = len(h['defname'])  # date size 11 characters. Format 00-ooo-0000
    if k < 6:
        for i in range(k, 6):
            h['defname'] += "."
    elif k > 6:
        h['defname'] = h['defname'][0:6]
    fout.write(h['defname'])

    k = len(h['tapeID'])  # date size 11 characters. Format 00-ooo-0000
    if k < 24:
        for i in range(k, 24):
            h['tapeID'] += "."
    elif k > 24:
        h['tapeID'] = h['tapeID'][0:24]
    fout.write(h['tapeID'])

    fout.write(struct.pack('i', h['ipatch']))
    fout.write(struct.pack('i', h['npatch']))
    fout.write(struct.pack('f', h['Emem']))
    fout.write(struct.pack('f', h['temp']))

    fout.seek(512)
    data.tofile(fout)

    fout.close()

def abf2ssd(abf_h):
    """
    Convert ABF file header into SSD file header.
    """

    ssd_h = {}

    ssd_h['version'] = np.int16(1002)
    ssd_h['title'] = "Converted from ABF"

    ssd_h['date'] = abf_h['IFileStartDate']
    ssd_h['time'] = abf_h['IFileStartTime']

    ssd_h['idt'] = np.int16(abf_h['fADCSampleInterval'] * abf_h['nADCNumChannels'])
    ssd_h['ioff'] = int(512)
    ssd_h['ilen'] = int(2 * abf_h['IActualAcqLength'] / abf_h['nADCNumChannels'])
    ssd_h['inc'] = np.int16(1)
    ssd_h['id1'] = np.int16(0)
    ssd_h['id2'] = np.int16(0)

    ssd_h['cs'] = "H"

    ssd_h['calfac'] = float(1 / (6553.6 *
        abf_h['fInstrumentScaleFactor'][abf_h['nADCSamplingSeq'][0]]))
    ssd_h['srate'] = float(1e6 / (abf_h['fADCSampleInterval'] *
        abf_h['nADCNumChannels']))
    ssd_h['filt'] = float(abf_h['fSignalLowpassFilter'][abf_h['nADCSamplingSeq'][0]])
    ssd_h['filt1'] = float(0.0)
    ssd_h['calfac1'] = float(0.0)

    ssd_h['expdate'] = abf_h['IFileStartDate']
    ssd_h['defname'] = "Converted"
    ssd_h['tapeID'] = "Converted"

    ssd_h['ipatch'] = int(3)
    ssd_h['npatch'] = int(1)
    ssd_h['Emem'] = float(0.0)
    ssd_h['temp'] = float(0.0)

    return ssd_h

def ini_HJCFIT_read(filename, verbose=False):
    """
    Read HJCFIT ini (configuration) file.
    
    iftype=100 (from windows) read pfiles and qmec which have the long path
    included character*60 qmec, pfiles(20,10) rather than DOS versions
    character*33 pfileb(20,10) character*40 qfilem.
    
    
    """
    
    ini = {}
    floats = array ('f')
    doubles = array('d')
    ints = array('i')
    
    f = open(filename, 'rb')
    ftype = f.read(8)
    f.close()
    f = open(filename, 'rb')
    ints.fromfile(f,1)
    iftype = ints.pop()
    f.close()
    f = open(filename, 'rb')
    
    if iftype == 100:
        ints.fromfile(f,1)
        iftype = ints.pop()
        ini['initype'] = iftype
        if verbose: print 'iftype=', iftype
    if ftype == 'windows':
        ftype = f.read(8)
        ini['initype'] = ftype
        if verbose: print 'ftype=', ftype

    # path names for scn files
    pfiles = []
    for i in range(20):
        temp = []
        for j in range(10):
            if iftype == 100:
                temp.append(f.read(60))
            else:
                temp.append(f.read(33))
        pfiles.append(temp)
    if verbose: print 'pfiles:', pfiles

    # number of fixed rates
    ints.fromfile(f,1)
    nfix = ints.pop()
    if verbose: print 'nfix=', nfix
    # mark fixed rates
    jfix = []
    for i in range(200):
        ints.fromfile(f,1)
        jfix.append(ints.pop())
    if verbose: print 'jfix=', jfix

    ints.fromfile(f,1)
    neq = ints.pop()
    if verbose: print 'neq=', neq

    ie = []
    for i in range(200):
        ints.fromfile(f,1)
        ie.append(ints.pop())
    if verbose: print 'ie=', ie

    je = []
    for i in range(200):
        ints.fromfile(f,1)
        je.append(ints.pop())
    if verbose: print 'je=', je

    efac = []
    for i in range(200):
        floats.fromfile(f,1)
        efac.append(floats.pop())
    if verbose: print 'efac=', efac

    iff = []
    for i in range(200):
        ints.fromfile(f,1)
        iff.append(ints.pop())
    if verbose: print 'iff=', iff

    jff = []
    for i in range(200):
        ints.fromfile(f,1)
        jff.append(ints.pop())
    if verbose: print 'jff=', jff

    # mark constrained rates
    jcon = []
    for i in range(200):
        ints.fromfile(f,1)
        jcon.append(ints.pop())
    if verbose: print 'jcon=', jcon

    im = []
    for i in range(50):
        temp = []
        for j in range(100):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        im.append(temp)
    if verbose: print 'im', im
    jm = []
    for i in range(50):
        temp = []
        for j in range(100):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        jm.append(temp)
    if verbose: print 'jm', jm

    # mark rates constrained by microscopic reversibility
    jmic = []
    for i in range(200):
        ints.fromfile(f,1)
        jmic.append(ints.pop())
    if verbose: print 'jmic=', jmic

    ints.fromfile(f,1)
    ndisp = ints.pop()
    if verbose: print 'ndisp=', ndisp

    ints.fromfile(f,1)
    irecq = ints.pop()
    if verbose: print 'irecq=', irecq

    ans1 = f.read(1)
    if verbose: print 'ans1', ans1

    ylo = []
    for i in range(20):
        floats.fromfile(f,1)
        ylo.append(floats.pop())
    if verbose: print 'ylo=', ylo

    yhi = []
    for i in range(20):
        floats.fromfile(f,1)
        yhi.append(floats.pop())
    if verbose: print 'yhi=', yhi

    ints.fromfile(f,1)
    nrange = ints.pop()
    if verbose: print 'nrange=', nrange

    ints.fromfile(f,1)
    idiskq = ints.pop()
    if verbose: print 'idiskq=', idiskq

    # Number of scn files to concatenate for each concentration
    nfileb = []
    for i in range(10):
        ints.fromfile(f,1)
        nfileb.append(ints.pop())
    if verbose: print 'nfileb', nfileb

    kfile = []
    for i in range(20):
        temp = []
        for j in range(10):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        kfile.append(temp)
    if verbose: print 'kfile', kfile
  
    # Rate set number in mec file
    ints.fromfile(f,1)
    nset = ints.pop()
    if verbose: print 'nset=', nset

    conc = []
    for i in range(10):
        temp = []
        for j in range(10):
            floats.fromfile(f,1)
            temp.append(floats.pop())
        conc.append(temp)
    if verbose: print 'conc', conc

    tcrit = []
    for i in range(10):
        floats.fromfile(f,1)
        tcrit.append(floats.pop())
    if verbose: print 'tcrit=', tcrit

    burst = []
    for i in range(10):
        ints.fromfile(f,1)
        burst.append(ints.pop())
    if verbose: print 'burst=', burst

    ints.fromfile(f,1)
    irecq1 = ints.pop()
    if verbose: print 'irecq1=', irecq1

    ints.fromfile(f,1)
    idatyp = ints.pop()
    if verbose: print 'idatyp=', idatyp

    # path for plq file
    qfile = f.read(40)
    if verbose: print 'qfile:', qfile

    # model number
    ints.fromfile(f,1)
    imodold = ints.pop()
    if verbose: print 'imodold=', imodold

    # set bad 0=shut, 1=open intervals
    setbad = []
    for i in range(2):
        temp = []
        for j in range(10):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        setbad.append(temp)
    if verbose: print 'setbad', setbad
    tcbad = []
    for i in range(2):
        temp = []
        for j in range(10):
            floats.fromfile(f,1)
            temp.append(floats.pop())
        tcbad.append(temp)
    if verbose: print 'tcbad', tcbad

    # one channel only?
    ints.fromfile(f,1)
    onechan = ints.pop()
    if verbose: print 'onechan=', onechan

    nbad1 = []
    for i in range(10):
        ints.fromfile(f,1)
        nbad1.append(ints.pop())
    if verbose: print 'nbad1=', nbad1

    # set bad bits from stability plots
    isbad = []
    for i in range(20):
        temp = []
        for j in range(10):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        isbad.append(temp)
    if verbose: print 'isbad', isbad
    iebad = []
    for i in range(20):
        temp = []
        for j in range(10):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        iebad.append(temp)
    if verbose: print 'iebad', iebad

    tresolb = []
    for i in range(10):
        floats.fromfile(f,1)
        tresolb.append(floats.pop())
    if verbose: print 'tresolb=', tresolb

    ans3 = f.read(1)
    if verbose: print 'ans3', ans3

    ans4 = f.read(1)
    if verbose: print 'ans4', ans4

    ints.fromfile(f,1)
    nlvar = ints.pop()
    if verbose: print 'nlvar=', nlvar

    ints.fromfile(f,1)
    fixec50 = ints.pop()
    if verbose: print 'fixec50=', fixec50

    doubles.fromfile(f,1)
    ec50 = doubles.pop()
    if verbose: print 'ec50=', ec50

    ints.fromfile(f,1)
    i50 = ints.pop()
    if verbose: print 'i50=', i50

    ints.fromfile(f,1)
    j50 = ints.pop()
    if verbose: print 'j50=', j50

    ints.fromfile(f,1)
    m50 = ints.pop()
    if verbose: print 'm50=', m50

    doubles.fromfile(f,1)
    xqlo = doubles.pop()
    if verbose: print 'xqlo=', xqlo

    doubles.fromfile(f,1)
    xqhi = doubles.pop()
    if verbose: print 'xqhi=', xqhi

    # number of open and shut states
    ints.fromfile(f,1)
    kAm = ints.pop()
    if verbose: print 'kAm=', kAm
    ints.fromfile(f,1)
    kFm = ints.pop()
    if verbose: print 'kFm=', kFm

    # use CHS vectors
    chsvec = []
    for i in range(10):
        ints.fromfile(f,1)
        chsvec.append(ints.pop())
    if verbose: print 'chsvec=', chsvec

    ints.fromfile(f,1)
    ncyc2 = ints.pop()
    if verbose: print 'ncyc2=', ncyc2

    # Get number of states in each cycle and connections.
    nsc2 = []
    for i in range(0, ncyc2):
        ints.fromfile(f,1)
        nsc2.append(ints.pop())
    if verbose: print "nsc2=", nsc2
    im2 = []
    for i in range(0, ncyc2):
        temp = []
        for j in range(0, nsc2[i]):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        im2.append(temp)
    if verbose: print "im2=",im2
    jm2 = []
    for i in range(0, ncyc2):
        temp = []
        for j in range(0, nsc2[i]):
            ints.fromfile(f,1)
            temp.append(ints.pop())
        jm2.append(temp)
    if verbose: print "jm2=", jm2

    # association rate limit
    doubles.fromfile(f,1)
    assmax = doubles.pop()
    if verbose: print 'assmax=', assmax

    # mec file path
    if iftype == 100:
        qmec = f.read(60)
    else:
        qmec = f.read(40)
    if verbose: print 'qmec', qmec

    ints.fromfile(f,1)
    nsim = ints.pop()
    if verbose: print 'nsim=', nsim

    ints.fromfile(f,1)
    irect = ints.pop()
    if verbose: print 'irect=', irect

    ints.fromfile(f,1)
    logsav = ints.pop()
    if verbose: print 'logsav=', logsav

    ints.fromfile(f,1)
    imodolds = ints.pop()
    if verbose: print 'imodolds=', imodolds

    badend = []
    for i in range(10):
        ints.fromfile(f,1)
        badend.append(ints.pop())
    if verbose: print 'badend=', badend

    iexcop = []
    for i in range(10):
        ints.fromfile(f,1)
        iexcop.append(ints.pop())
    if verbose: print 'iexcop=', iexcop

    gaplo = []
    for i in range(10):
        floats.fromfile(f,1)
        gaplo.append(floats.pop())
    if verbose: print 'gaplo=', gaplo

    gaphi = []
    for i in range(10):
        floats.fromfile(f,1)
        gaphi.append(floats.pop())
    if verbose: print 'gaphi=', gaphi

    ints.fromfile(f,1)
    dcmod = ints.pop()
    if verbose: print 'dcmod=', dcmod

    # parameters for grouped (closely spaced) asymptotic roots
    ints.fromfile(f,1)
    slopsch = ints.pop()
    if verbose: print 'slopsch=', slopsch

    ints.fromfile(f,1)
    checkgrp = ints.pop()
    if verbose: print 'checkgrp=', checkgrp

    doubles.fromfile(f,1)
    rcrit = doubles.pop()
    if verbose: print 'rcrit=', rcrit

    ints.fromfile(f,1)
    ngpcheck = ints.pop()
    if verbose: print 'ngpcheck=', ngpcheck

    # parameters for using narrower guesses when fit is stabilised
    # 200 evals since last rootsch call
    ints.fromfile(f,1)
    nstab1 = ints.pop()
    if verbose: print 'nstab1=', nstab1
    # guesses = rootF +/- 10% after nstab1 evaluations
    doubles.fromfile(f,1)
    gfac1 = doubles.pop()
    if verbose: print 'gfac1=', gfac1
    # 500 evals since last rootsch call
    ints.fromfile(f,1)
    nstab2 = ints.pop()
    if verbose: print 'nstab2=', nstab2
    # guesses = rootF +/- 2% after nstab2 evaluations
    doubles.fromfile(f,1)
    gfac2 = doubles.pop()
    if verbose: print 'gfac2=', gfac2

    ans5 = f.read(1)
    if verbose: print 'ans5', ans5


    ints.fromfile(f,1)
    nfixec50 = ints.pop()
    if verbose: print 'nfixec50=', nfixec50

    doubles.fromfile(f,1)
    ec502 = doubles.pop()
    if verbose: print 'ec502=', ec502

    ints.fromfile(f,1)
    i502 = ints.pop()
    if verbose: print 'i502=', i502

    ints.fromfile(f,1)
    j502 = ints.pop()
    if verbose: print 'j502=', j502

    ints.fromfile(f,1)
    m502 = ints.pop()
    if verbose: print 'm502=', m502

    doubles.fromfile(f,1)
    xqlo2 = doubles.pop()
    if verbose: print 'xqlo2=', xqlo2

    doubles.fromfile(f,1)
    xqhi2 = doubles.pop()
    if verbose: print 'xqhi2=', xqhi2

    ints.fromfile(f,1)
    useprim = ints.pop()
    if verbose: print 'useprim=', useprim

    isetmr = []
    for i in range(0, ncyc2):
        ints.fromfile(f,1)
        isetmr.append(ints.pop())
    if verbose: print "isetmr=", isetmr

    doubles.fromfile(f,1)
    ratemax = doubles.pop()
    if verbose: print 'ratemax=', ratemax

    # number of rates actually set by microscopic reversibility
    ints.fromfile(f,1)
    nmr = ints.pop()
    if verbose: print 'nmr=', nmr

    # number of ligands
    ints.fromfile(f,1)
    nlig = ints.pop()
    if verbose: print 'nlig=', nlig

    conc_ec1 = []
    for i in range(0, nlig):
        floats.fromfile(f,1)
        conc_ec1.append(floats.pop())
    if verbose: print "conc_ec1=", conc_ec1

    conc_ec2 = []
    for i in range(0, nlig):
        floats.fromfile(f,1)
        conc_ec2.append(floats.pop())
    if verbose: print "conc_ec2=", conc_ec2

    f.close()
    
    ini['scn_files'] = []
    for i in range(nset):
        temp = []
        for j in range(nfileb[i]):
            temp.append(pfiles[j][i].strip())
        ini['scn_files'].append(temp)
    ini['mec_file'] = qmec.strip()
    ini['mec_num'] = imodold
    ini['mec_rates'] = irecq
    ini['fix_num'] = nfix
    ini['fix_rates'] = jfix
    ini['constr_num'] = neq
    ini['constr_fixed'] = [ie[:neq], je[:neq]]
    ini['constr_torate'] = [iff[:neq], jff[:neq]]
    ini['constr_fact'] = efac[:neq]
    ini['conc_dep_rates'] = jcon
    ini['conc_dep_rates_states'] = [im, jm]
    ini['mr_constr_rates'] = jmic
    ini['tcrit'] = tcrit[:nset]
    ini['chsvec'] = chsvec[:nset]
    ini['tres'] = tresolb[:nset]
    ini['conc'] = []
    for i in range(nset):
        temp = []
        for j in range(nfileb[i]):
            temp.append(conc[j][i])
        ini['conc'].append(temp)
    ini['ec50'] = ec50
    ini['cycles'] = [im2, jm2]
    ini['assmax'] = assmax
    ini['ratemax'] = ratemax
    
    return ini

def txt_load_one_col(filename):
    """"
    Read one column of data from a text file.
    """

    f = open(filename, 'r')
    lines = f.readlines()
    f.close()
    data = []
    for line in lines:
        if line != '\n':
            value = float(line.strip("\t\n"))    #divide lines into values at tabs
#            print 'value=', value
            data.append(value)

    print "number of original intervals =", len(lines)
    print "number of useful intervals =", len(data)
    return data

def png_save_pdf_fig(outfile, ints, mec, conc, tres, type):
    x, y, dx = scpl.prepare_hist(ints, tres)
    mec.set_eff('c', conc)
    if type == 'open':
        t, ipdf, epdf, apdf = scpl.open_time_pdf(mec, tres)
    elif type == 'shut':
        t, ipdf, epdf, apdf = scpl.shut_time_pdf(mec, tres)
    else:
        print 'Wrong type.'

    sipdf = scpl.scaled_pdf(t, ipdf, math.log10(dx), len(ints))
    sepdf = scpl.scaled_pdf(t, epdf, math.log10(dx), len(ints))
    figure(figsize=(6, 4))
    semilogx(x*1000, y, 'k-', t, sipdf, 'r--', t, sepdf, 'b-')
    savefig(outfile, bbox_inches=0)